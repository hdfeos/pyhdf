<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Table of contents &mdash; pyhdf 0.9 documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.9',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="pyhdf 0.9 documentation" href="../index.html" />
    <link rel="next" title="Table of contents" href="V.html" />
    <link rel="prev" title="Table of contents" href="SD.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="V.html" title="Table of contents"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="SD.html" title="Table of contents"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">pyhdf 0.9 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <span class="target" id="module-pyhdf.VS"></span><p>A module of the pyhdf package implementing the VS (Vdata table)
API of the NCSA HDF4 library.
(see: hdf.ncsa.uiuc.edu)</p>
<dl class="docutils">
<dt>Author: Andre Gosselin</dt>
<dd>Maurice-Lamontagne Institute
<a class="reference external" href="mailto:gosselina&#37;&#52;&#48;dfo-mpo&#46;gc&#46;ca">gosselina<span>&#64;</span>dfo-mpo<span>&#46;</span>gc<span>&#46;</span>ca</a></dd>
</dl>
<p>Version: 0.7-3
Date:    July 13 2005</p>
<div class="section" id="table-of-contents">
<h1>Table of contents<a class="headerlink" href="#table-of-contents" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div><p>Introduction
VS module key features
Accessing the VS module
Package components
Prerequisites
Documentation
Summary of differences between the pyhdf and C VS API
Error handling
VS needs support from the HDF module
Classes summary
Data types
Attribute access: low and high level
Predefined attributes
Record access: low and high level
Programming models</p>
<blockquote>
<div>Creating and initializing a new vdata
Appending records to a vdata
Updating records in a vdata
Reading a vdata</div></blockquote>
<p>Module documentation</p>
</div></blockquote>
</div>
<div class="section" id="introduction">
<h1>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h1>
<p>VS is one of the modules composing pyhdf, a python package implementing
the NCSA HDF library and letting one manage HDF files from within a python
program. Two versions of the HDF library currently exist, version 4 and
version 5. pyhdf only implements version 4 of the library. Many
different APIs are to be found inside the HDF4 specification.
Currently, pyhdf implements just a few of those: the SD, VS and V APIs.
Other APIs should be added in the future (GR, AN, etc).</p>
<p>VS allows the definition of structured data tables inside an HDF file.
Those tables are designated as &#8220;vdatas&#8221; (the name has to do with data
associated with the &#8220;vertices&#8221; of geometrical models, the storage of which
the API was originally designed for). A vdata is composed of a fixed
number of columns (also called fields), where a column can store a fixed
number of data values, all of the same type. The number of values allowed
inside a field is called the &#8220;order&#8221; of the field. A table is composed of a
varying number of rows (also called records), a record representing the
sequence of values stored in each field of the vdata.</p>
<p>A vdata is associated with a descriptive name, and likewise each field of
the vdata. A vdata can also be tagged with a &#8220;class&#8221; to further describe the
vdata purpose. Records and fields are identified by a zero-based index.
An arbitrary number of attributes of different types can be attached to
a vdata as a whole, or to its individual fields. An attribute is a
(name, value) pair, where &#8220;value&#8221; can be of many types, and be either
single or multi-valued. The number of values stored in an attribute is
called the &#8220;order&#8221; of the attribute.</p>
<p>The following example illustrates a simple vdata that could be stored
inside an HDF file. See section &#8220;Programming models&#8221; for an example
program implementing this vdata.</p>
<blockquote>
<div><blockquote>
<div>INVENTORY (experimental status)</div></blockquote>
<p>&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;i&#8212;&#8212;-
partid     description     qty   wght(lb)  price($)
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;
Q1234       bolt           12     0.01      0.05
B5432       brush          10     0.4       4.25
S7613       scissor         2     0.2       3.75</p>
</div></blockquote>
<p>The vdata is composed of 5 fields. 3 records are shown (of course, a vdata
can store much more than that). &#8220;INVENTORY&#8221; would be the vdata name, and
&#8220;partid&#8221;, &#8220;description&#8221;, etc, would be the field names. The data type varies
between fields. &#8220;partid&#8221; and &#8220;description&#8221; would be of &#8220;multicharacter&#8221; type
(aka &#8220;string&#8221;), &#8220;qty&#8221; would be a integer, and &#8220;wght&#8221; and &#8220;price&#8221; would be
floats. The text in parentheses could be stored as attributes. A &#8220;status&#8221;
attribute could be defined for the table as a whole, and given the
value &#8220;experimental&#8221;. Likewise, a &#8220;unit&#8221; attribute could be associated
with fields &#8220;wght&#8221; and &#8220;price&#8221;, and given the values &#8220;lb&#8221; and &#8220;$&#8221;, resp.</p>
<p>The VS API allows one to create, locate and open a vdata inside an
HDF file, update and append records inside it, read records randomly
or sequentially, and access and update the vdata and field attributes.
Attributes can be read and written using the familiar python &#8220;dot
notation&#8221;, and records can be read and written by indexing and slicing the
vdata as if it were a python sequence.</p>
</div>
<div class="section" id="vs-module-key-features">
<h1>VS module key features<a class="headerlink" href="#vs-module-key-features" title="Permalink to this headline">¶</a></h1>
<p>VS key features are as follows.</p>
<blockquote>
<div><dl class="docutils">
<dt>-pyhdf implements almost every routine of the original VS API.</dt>
<dd><dl class="first last docutils">
<dt>Only a few have been ignored, most of them being of a rare use:</dt>
<dd><ul class="first last simple">
<li>VSgetblocksize() / VSsetblocksize()</li>
<li>VSsetnumblocks()</li>
<li>VSlone</li>
</ul>
</dd>
</dl>
</dd>
<dt>-It is quite straightforward to go from a C version to a python version</dt>
<dd>of a program accessing the VS API, and to learn VS usage by refering to
the C API documentation.</dd>
<dt>-A few high-level python methods have been developped to ease</dt>
<dd><dl class="first last docutils">
<dt>programmers task. Of greatest interest are the following:</dt>
<dd><ul class="first last simple">
<li>Access to attributes through the familiar &#8220;dot notation&#8221;.</li>
<li>Indexing and slicing a vdata to read and write its records,
similarly to a python sequence.</li>
<li>Easy retrieval of info on a vdata and its fields.</li>
<li>Easy creation of vdatas.</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</div>
<div class="section" id="accessing-the-vs-module">
<h1>Accessing the VS module<a class="headerlink" href="#accessing-the-vs-module" title="Permalink to this headline">¶</a></h1>
<p>To access the VS module a python program can say one of:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyhdf.VS</span>        <span class="c"># must prefix names with &quot;pyhdf.VS.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyhdf</span> <span class="kn">import</span> <span class="n">VS</span>   <span class="c"># must prefix names with &quot;VS.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyhdf.VS</span> <span class="kn">import</span> <span class="o">*</span> <span class="c"># names need no prefix</span>
</pre></div>
</div>
<p>This document assumes the last import style is used.</p>
<p>VS is not self-contained, and needs functionnality provided by another
pyhdf module, namely the HDF module. This module must thus be imported
also:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">HDF</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
</div>
<div class="section" id="package-components">
<h1>Package components<a class="headerlink" href="#package-components" title="Permalink to this headline">¶</a></h1>
<p>pyhdf is a proper Python package, eg a collection of modules stored under
a directory whose name is that of the package and which stores an
__init__.py file. Following the normal installation procedure, this
directory will be &lt;python-lib&gt;/site-packages/pyhdf&#8217;, where &lt;python-lib&gt;
stands for the python installation directory.</p>
<p>For each HDF API exists a corresponding set of modules.</p>
<p>The following modules are related to the VS API.</p>
<blockquote>
<div><dl class="docutils">
<dt>_hdfext   C extension module responsible for wrapping the HDF</dt>
<dd>C library for all python modules</dd>
<dt>hdfext    python module implementing some utility functions</dt>
<dd>complementing the _hdfext extension module</dd>
</dl>
<p>error     defines the HDF4Error exception
HDF       python module providing support to the VS module
VS        python module wrapping the VS API routines inside</p>
<blockquote>
<div>an OOP framework</div></blockquote>
</div></blockquote>
<p>_hdfext and hdfext were generated using the SWIG preprocessor.
SWIG is however <em>not</em> needed to run the package. Those two modules
are meant to do their work in the background, and should never be called
directly. Only HDF and VS should be imported by the user program.</p>
</div>
<div class="section" id="prerequisites">
<h1>Prerequisites<a class="headerlink" href="#prerequisites" title="Permalink to this headline">¶</a></h1>
<p>The following software must be installed in order for VS to
work.</p>
<blockquote>
<div><dl class="docutils">
<dt>HDF (v4) library</dt>
<dd><p class="first">pyhdf does <em>not</em> include the HDF4 library, which must
be installed separately.</p>
<p class="last">HDF is available at:
&#8220;<a class="reference external" href="http://hdf.ncsa.uiuc.edu/obtain.html">http://hdf.ncsa.uiuc.edu/obtain.html</a>&#8221;.</p>
</dd>
</dl>
</div></blockquote>
<p>Numeric is also needed by the SD module. See the SD module documentation.</p>
</div>
<div class="section" id="documentation">
<h1>Documentation<a class="headerlink" href="#documentation" title="Permalink to this headline">¶</a></h1>
<p>pyhdf has been written so as to stick as closely as possible to 
the naming conventions and calling sequences documented inside the
&#8220;HDF User s Guide&#8221; manual. Even if pyhdf gives an OOP twist
to the C API, the manual can be easily used as a documentary source
for pyhdf, once the class to which a function belongs has been
identified, and of course once requirements imposed by the Python
langage have been taken into account. Consequently, this documentation
will not attempt to provide an exhaustive coverage of the HDF VS
API. For this, the user is referred to the above manual.
The documentation of each pyhdf method will indicate the name
of the equivalent routine as it is found inside the C API.</p>
<p>This document (in both its text and html versions) has been completely
produced using &#8220;pydoc&#8221;, the Python documentation generator (which
made its debut in the 2.1 Python release). pydoc can also be used
as an on-line help tool. For example, to know everything about
the VS.VD class, say:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pydoc</span> <span class="kn">import</span> <span class="n">help</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyhdf.VS</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">help</span><span class="p">(</span><span class="n">VD</span><span class="p">)</span>
</pre></div>
</div>
<p>To be more specific and get help only for the read() method of the
VD class:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">help</span><span class="p">(</span><span class="n">VD</span><span class="o">.</span><span class="n">read</span><span class="p">)</span> 
</pre></div>
</div>
<p>pydoc can also be called from the command line, as in:</p>
<blockquote>
<div>% pydoc pyhdf.VS.VD         # doc for the whole VD class
% pydoc pyhdf.VS.VD.read    # doc for the VD.read method</div></blockquote>
</div>
<div class="section" id="summary-of-differences-between-the-pyhdf-and-c-vs-api">
<h1>Summary of differences between the pyhdf and C VS API<a class="headerlink" href="#summary-of-differences-between-the-pyhdf-and-c-vs-api" title="Permalink to this headline">¶</a></h1>
<p>Most of the differences between the pyhdf and C VS API can
be summarized as follows.</p>
<blockquote>
<div><dl class="docutils">
<dt>-In the C API, every function returns an integer status code, and values</dt>
<dd>computed by the function are returned through one or more pointers
passed as arguments.</dd>
<dt>-In pyhdf, error statuses are returned through the Python exception</dt>
<dd>mechanism, and values are returned as the method result. When the
C API specifies that multiple values are returned, pyhdf returns a 
sequence of values, which are ordered similarly to the pointers in the
C function argument list.</dd>
</dl>
</div></blockquote>
</div>
<div class="section" id="error-handling">
<h1>Error handling<a class="headerlink" href="#error-handling" title="Permalink to this headline">¶</a></h1>
<p>All errors reported by the C VS API with a SUCCESS/FAIL error code
are reported by pyhdf using the Python exception mechanism.
When the C library reports a FAIL status, pyhdf raises an HDF4Error
exception (a subclass of Exception) with a descriptive message. 
Unfortunately, the C library is rarely informative about the cause of 
the error. pyhdf does its best to try to document the error, but most 
of the time cannot do more than saying &#8220;execution error&#8221;.</p>
</div>
<div class="section" id="vs-needs-support-from-the-hdf-module">
<h1>VS needs support from the HDF module<a class="headerlink" href="#vs-needs-support-from-the-hdf-module" title="Permalink to this headline">¶</a></h1>
<p>The VS module is not self-contained (countrary to the SD module).
It requires help from the HDF module, namely:</p>
<blockquote>
<div><dl class="docutils">
<dt>-the HDF.HDF class to open and close the HDF file, and initialize the</dt>
<dd>VS interface</dd>
<dt>-the HDF.HC class to provide different sorts of constants (opening modes,</dt>
<dd>data types, etc).</dd>
</dl>
</div></blockquote>
<p>A program wanting to access HDF vdatas will almost always need to execute
the following minimal set of calls:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyhdf.HDF</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyhdf.VS</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdfFile</span> <span class="o">=</span> <span class="n">HDF</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">HC</span><span class="o">.</span><span class="n">xxx</span><span class="p">)</span><span class="c"># open HDF file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vs</span> <span class="o">=</span> <span class="n">hdfFile</span><span class="o">.</span><span class="n">vstart</span><span class="p">()</span>      <span class="c"># initialize VS interface on HDF file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">...</span>                        <span class="c"># manipulate vdatas through &quot;vs&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vs</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>                   <span class="c"># terminate VS interface</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdfFile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>            <span class="c"># close HDF file</span>
</pre></div>
</div>
</div>
<div class="section" id="classes-summary">
<h1>Classes summary<a class="headerlink" href="#classes-summary" title="Permalink to this headline">¶</a></h1>
<p>pyhdf wraps the VS API using different python classes:</p>
<blockquote>
<div>VS      HDF VS interface
VD      vdata
VDField vdata field
VDattr  attribute (either at the vdata or field level)</div></blockquote>
<p>In more detail:</p>
<blockquote>
<div><dl class="docutils">
<dt>VS     The VS class implements the VS (Vdata) interface applied to an</dt>
<dd><p class="first">HDF file. This class encapsulates the hdf instance, and all
the top-level functions of the VS API.</p>
<p>To create a VS instance, call the vstart() method of an
HDF instance.</p>
<dl class="last docutils">
<dt>methods:</dt>
<dd><dl class="first last docutils">
<dt>constructors:</dt>
<dd><dl class="first last docutils">
<dt>attach()       open an existing vdata given its name or</dt>
<dd>reference number, or create a new one,
returning a VD instance</dd>
<dt>create()       create a new vdata and define its structure,</dt>
<dd>returning a VD instance</dd>
</dl>
</dd>
<dt>creating and initializing a simple vdata</dt>
<dd><dl class="first last docutils">
<dt>storedata()    create a single-field vdata and initialize</dt>
<dd>its values</dd>
</dl>
</dd>
<dt>closing the interface</dt>
<dd>end()          close the VS interface on the HDF file</dd>
<dt>searching</dt>
<dd><p class="first">find()         get a vdata reference number given its name
next()         get the reference number of the vdata following</p>
<blockquote class="last">
<div>a given one</div></blockquote>
</dd>
<dt>inquiry</dt>
<dd><dl class="first last docutils">
<dt>vdatainfo()    return info about all the vdatas in the</dt>
<dd>HDF file</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>VD     The VD class describes a vdata. It encapsulates</dt>
<dd><p class="first">the VS instance to which the vdata belongs, and the vdata
identifier.</p>
<p>To instantiate a VD class, call the attach() or create()
method of a VS class instance.</p>
<dl class="last docutils">
<dt>methods:</dt>
<dd><dl class="first last docutils">
<dt>constructors</dt>
<dd><dl class="first last docutils">
<dt>attr()         create a VDAttr instance representing a</dt>
<dd>vdata attribute; &#8220;dot notation&#8221; can also be
used to access a vdata attribute</dd>
<dt>field()        return a VDField instance representing a given</dt>
<dd>field of the vdata</dd>
</dl>
</dd>
<dt>closing vdata</dt>
<dd>detach()       end access to the vdata</dd>
<dt>defining fields</dt>
<dd><p class="first">fdefine()      define the name, type and order of a new field
setfields()    define the field names and field order for</p>
<blockquote class="last">
<div>the read() and write() methods; also used to
initialize the structure of a vdata previously
created with the VS.attach() method</div></blockquote>
</dd>
<dt>reading and writing</dt>
<dd><blockquote class="first">
<div>note: a vdata can be indexed and sliced like a
python sequence</div></blockquote>
<dl class="docutils">
<dt>read()         return the values of a number of records</dt>
<dd>starting at the current record position</dd>
</dl>
<p>seek()         reset the current record position
seekend()      seek past the last record
tell()         return the current record position
write()        write a number of records starting at the</p>
<blockquote class="last">
<div>current record position</div></blockquote>
</dd>
<dt>inquiry</dt>
<dd><p class="first">attrinfo()     return info about all the vdata attributes
fexist()       check if a vdata contains a given set of fields
fieldinfo()    return info about all the vdata fields
findattr()     locate an attribute, returning a VDAttr instance</p>
<blockquote>
<div>if found</div></blockquote>
<p class="last">inquire()      return info about the vdata
sizeof()       return the size in bytes of one or more fields</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>VDField  The VDField class represents a vdata field. It encapsulates</dt>
<dd><p class="first">the VD instance to which the field belongs, and the field
index number.</p>
<p>To instantiate a VDField, call the field() method of a VD class
instance.</p>
<dl class="last docutils">
<dt>methods:</dt>
<dd><dl class="first last docutils">
<dt>constructors:</dt>
<dd><dl class="first last docutils">
<dt>attr()       return a VDAttr instance representing an</dt>
<dd>attribute of the field; &#8220;dot notation&#8221;
can also be used to get/set an attribute.</dd>
</dl>
</dd>
<dt>inquiry</dt>
<dd><p class="first">attrinfo()   return info about all the field attributes
find()       locate an attribute, returning a VDAttr</p>
<blockquote class="last">
<div>instance if found</div></blockquote>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>VDAttr   The VDAttr class encapsulates methods used to set and query</dt>
<dd><p class="first">attributes defined at the level either of the vdata or the
vdata field.</p>
<p>To create an instance of this class, call the attr() or
findattr() methods of a VD instance (for vdata attributes),
or call the attr() or find() methods of a VDField instance
(for field attributes).</p>
<dl class="last docutils">
<dt>methods:</dt>
<dd><dl class="first last docutils">
<dt>get / set</dt>
<dd>get()        get the attribute value
set()        set the attribute value</dd>
<dt>info</dt>
<dd>info()       retrieve info about the attribute</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</div>
<div class="section" id="data-types">
<h1>Data types<a class="headerlink" href="#data-types" title="Permalink to this headline">¶</a></h1>
<p>Data types come into play when first defining vdata fields and attributes,
and later when querying the definition of those fields and attributes.
Data types are specified using the symbolic constants defined inside the
HC class of the HDF module.</p>
<blockquote>
<div><ul class="simple">
<li>CHAR and CHAR8 (equivalent): an 8-bit character.</li>
<li>UCHAR, UCHAR8 and UINT8 (equivalent): unsigned 8-bit values (0 to 255)</li>
<li>INT8:    signed 8-bit values (-128 to 127)</li>
<li>INT16:   signed 16-bit values</li>
<li>UINT16:  unsigned 16 bit values</li>
<li>INT32:   signed 32 bit values</li>
<li>UINT32:  unsigned 32 bit values</li>
<li>FLOAT32: 32 bit floating point values (C floats)</li>
<li>FLOAT64: 64 bit floating point values (C doubles)</li>
</ul>
</div></blockquote>
<p>There is no explicit &#8220;string&#8221; type. To simulate a string, set the field or
attribute type to CHAR, and set the field or attribute &#8220;order&#8221; to
a value of &#8216;n&#8217; &gt; 1. This creates and &#8220;array of characters&#8221;, close
to a string (except that strings will always be of length &#8216;n&#8217;, right-padded
with spaces if necessary).</p>
</div>
<div class="section" id="attribute-access-low-and-high-level">
<h1>Attribute access: low and high level<a class="headerlink" href="#attribute-access-low-and-high-level" title="Permalink to this headline">¶</a></h1>
<p>The VS API allow setting attributes on vdatas and vdata fields. Attributes
can be of many types (int, float, char) of different bit lengths (8, 16, 32,
64 bits), and can be single or multi-valued. Values of a multi-valued
attribute must all be of the same type.</p>
<p>Attributes can be set and queried in two different ways. First, given a
VD instance (describing a vdata object) or a VDField instance (describing a
vdata field), the attr() method of that instance is called to create a
VDAttr instance representing the wanted attribute (possibly non existent).
The set() method of this VDAttr instance is then called to define the
attribute value, creating it if it does not already exist. The get() method
returns the current attribute value. Here is an example.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyhdf.HDF</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyhdf.VS</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">HDF</span><span class="p">(</span><span class="s">&#39;test.hdf&#39;</span><span class="p">,</span> <span class="n">HC</span><span class="o">.</span><span class="n">WRITE</span><span class="p">)</span> <span class="c"># Open file &#39;test.hdf&#39; in write mode</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vs</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">vstart</span><span class="p">()</span>            <span class="c"># init vdata interface</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vd</span> <span class="o">=</span> <span class="n">vs</span><span class="o">.</span><span class="n">attach</span><span class="p">(</span><span class="s">&#39;vtest&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c"># attach vdata &#39;vtest&#39; in write mode</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attr</span> <span class="o">=</span> <span class="n">vd</span><span class="o">.</span><span class="n">attr</span><span class="p">(</span><span class="s">&#39;version&#39;</span><span class="p">)</span>  <span class="c"># prepare to define the &#39;version&#39; attribute</span>
<span class="go">                               # on the vdata</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attr</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">HC</span><span class="o">.</span><span class="n">CHAR8</span><span class="p">,</span><span class="s">&#39;1.0&#39;</span><span class="p">)</span>   <span class="c"># set attribute &#39;version&#39; to string &#39;1.0&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">attr</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>           <span class="c"># get and print attribute value</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fld</span>  <span class="o">=</span> <span class="n">vd</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="s">&#39;fld1&#39;</span><span class="p">)</span>    <span class="c"># obtain a field instance for field &#39;fld1&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attr</span> <span class="o">=</span> <span class="n">fld</span><span class="o">.</span><span class="n">attr</span><span class="p">(</span><span class="s">&#39;range&#39;</span><span class="p">)</span>   <span class="c"># prepare to define attribute &#39;range&#39; on</span>
<span class="go">                               # this field</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attr</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">HC</span><span class="o">.</span><span class="n">INT32</span><span class="p">,(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">))</span> <span class="c"># set attribute &#39;range&#39; to a pair of ints</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">attr</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>             <span class="c"># get and print attribute value</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">vd</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>                <span class="c"># &quot;close&quot; the vdata</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vs</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>                   <span class="c"># terminate the vdata interface</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>                  <span class="c"># close the HDF file</span>
</pre></div>
</div>
<p>The second way consists of setting/querying an attribute as if it were a
normal python class attribute, using the usual dot notation. Above example
then becomes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyhdf.HDF</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyhdf.VS</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">HDF</span><span class="p">(</span><span class="s">&#39;test.hdf&#39;</span><span class="p">,</span> <span class="n">HC</span><span class="o">.</span><span class="n">WRITE</span><span class="p">)</span> <span class="c"># Open file &#39;test.hdf&#39; in write mode</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vs</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">vstart</span><span class="p">()</span>            <span class="c"># init vdata interface</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vd</span> <span class="o">=</span> <span class="n">vs</span><span class="o">.</span><span class="n">attach</span><span class="p">(</span><span class="s">&#39;vtest&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c"># attach vdata &#39;vtest&#39; in write mode</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vd</span><span class="o">.</span><span class="n">version</span> <span class="o">=</span> <span class="s">&#39;1.0&#39;</span>         <span class="c"># create vdata attribute &#39;version&#39;,</span>
<span class="go">                               # setting it to string &#39;1.0&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">vd</span><span class="o">.</span><span class="n">version</span>           <span class="c"># print attribute value</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fld</span>  <span class="o">=</span> <span class="n">vd</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="s">&#39;fld1&#39;</span><span class="p">)</span>    <span class="c"># obtain a field instance for field &#39;fld1&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fld</span><span class="o">.</span><span class="n">range</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>      <span class="c"># create field attribute &#39;range&#39;, setting</span>
<span class="go">                               # it to the pair of ints (-10, 15)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">fld</span><span class="o">.</span><span class="n">range</span>            <span class="c"># print attribute value</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vd</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>                <span class="c"># &quot;close&quot; the vdata</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vs</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>                   <span class="c"># terminate the vdata interface</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>                  <span class="c"># close the HDF file</span>
</pre></div>
</div>
<p>Note how the dot notation greatly simplifies and clarifies the code.
Some latitude is however lost by manipulating attributes in that way,
because the pyhdf package, not the programmer, is then responsible of
setting the attribute type. The attribute type is chosen to be one of:</p>
<blockquote>
<div>HC.CHAR8    if the attribute value is a string
HC.INT32    if all attribute values are integers
HC.FLOAT64  otherwise</div></blockquote>
<p>The first way of handling attribute values must be used if one wants to
define an attribute of any other type (for ex. 8 or 16 bit integers,
signed or unsigned). Also, only a VDAttr instance gives access to attribute
info, through its info() method.</p>
<p>However, accessing HDF attributes as if they were python attributes raises
an important issue. There must exist a way to assign generic attributes
to the python objects without requiring those attributes to be converted
to HDF attributes. pyhdf uses the following rule: an attribute whose name
starts with an underscore (&#8216;_&#8217;) is either a &#8220;predefined&#8221; attribute
(see below) or a standard python attribute. Otherwise, the attribute
is handled as an HDF attribute. Also, HDF attributes are not stored inside
the object dictionnary: the python dir() function will not list them.</p>
<p>Attribute values can be updated, but it is illegal to try to change the
value type, or the attribute order (number of values). This is important
for attributes holding string values. An attribute initialized with an
&#8216;n&#8217; character string is simply a character attribute of order &#8216;n&#8217; (eg a
character array of length &#8216;n&#8217;). If &#8216;vd&#8217; is a vdata and we initialize its
&#8216;a1&#8217; attribute as &#8216;vd.a1 = &#8220;abcdef&#8221;&#8217;, then a subsequent update attempt
like &#8216;vd.a1 = &#8220;12&#8221;&#8217; will fail, because we then try to change the order
of the attribute (from 6 to 2). It is mandatory to keep the length of string
attributes constant. Examples below show simple ways how this can be done.</p>
</div>
<div class="section" id="predefined-attributes">
<h1>Predefined attributes<a class="headerlink" href="#predefined-attributes" title="Permalink to this headline">¶</a></h1>
<p>The VD and VDField classes support predefined attributes to get (and
occasionnaly set) attribute values easily, without having to call a
class method. The names of predefined attributes all start with an
underscore (&#8216;_&#8217;).</p>
<p>In the following tables, the RW column holds an X if the attribute
is read/write. See the HDF User s guide for details about more
&#8220;exotic&#8221; topics like &#8220;class&#8221;, &#8220;faked vdata&#8221; and &#8220;tag&#8221;.</p>
<blockquote>
<div><p>VD predefined attributes</p>
<blockquote>
<div><p>_class      X   class name                 VSgetclass/VSsetclass
_fields         list of field names        VSgetfields
_interlace  X   interlace mode             VSgetinterlace/VSsetinterlace
_isattr         true if vdata is &#8220;faked&#8221;   VSisattr</p>
<blockquote>
<div>by HDF to hold attributes</div></blockquote>
<p>_name       X   name of the vdata          VSgetname/VSsetname
_nattrs         number of attributes       VSfnattrs
_nfields        number of fields           VFnfields
_nrecs          number of records          VSelts
_recsize        record size (bytes)        VSQueryvsize
_refnum         reference number           VSQueryref
_tag            vdata tag                  VSQuerytag
_tnattrs        total number of vdata and  VSnattrs</p>
<blockquote>
<div>field attributes</div></blockquote>
</div></blockquote>
<p>VDField predefined attributes</p>
<blockquote>
<div>_esize          external size (bytes)      VFfieldesize
_index          index number               VSfindex
_isize          internal size (bytes)      VFfieldisize
_name           name                       VFfieldname
_nattrs         number of attributes       VSfnattrs
_order          order (number of values)   VFfieldorder
_type           field type (HC.xxx)        VFfieldtype</div></blockquote>
</div></blockquote>
</div>
<div class="section" id="record-access-low-and-high-level">
<h1>Record access: low and high level<a class="headerlink" href="#record-access-low-and-high-level" title="Permalink to this headline">¶</a></h1>
<p>vdata records can be read and written in two different ways. The first one
consists of calling the basic I/O methods of the vdata:</p>
<blockquote>
<div><ul class="simple">
<li>seek() to set the current record position, if necessary;</li>
<li>read() to retrieve a given number of records from that position;</li>
<li>write() to write a given number of records starting at
that position</li>
</ul>
</div></blockquote>
<p>A second, higher level way, lets one see a vdata similarly to a python
sequence, and access its contents using the familiar indexing and slicing
notation in square brackets. Reading and writing a vdata as if it were a
python sequence may often look simpler, and improve code legibility.</p>
<p>Here are some examples of how a vdata &#8216;vd&#8217; holding 3 fields could be read.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">vd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>         <span class="c"># print record 0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">vd</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>        <span class="c"># print last record</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">vd</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>        <span class="c"># print records 2 and those that follow</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">vd</span><span class="p">[:]</span>         <span class="c"># print all records</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">vd</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>       <span class="c"># print field 0 of all records</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">vd</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span>     <span class="c"># print first 2 fields of first 3 records</span>
</pre></div>
</div>
<p>As the above examples show, the usual python rules are obeyed regarding
the interpretation of indexing and slicing values. Note that the vdata
fields can be indexed and sliced, not only the records. The setfields()
method can also be used to select a subset to the vdata fields
(setfields() also let you reorder the fields). When the vdata is
indexed (as opposed to being sliced), a single record is returned as a list
of values. When the vdata is sliced, a list of records is
always returned (thus a 2-level list), even if the slice contains only
one record.</p>
<p>A vdata can also be written similarly to a python sequence. When indexing
the vdata (as opposed to slicing it), a single record must be assigned,
and the record must be given as a sequence of values. It is legal to use
as an index the current number of records in the vdata: the record is then
appended to the vdata. When slicing the vdata, the records assigned to the
slice must always be given as a list of records, even
if only one record is assigned. Also, the number of records assigned must
always match the width of the slice, except if the slice includes or goes
past the last record of the vdata. In that case, the number of records
assigned can exceed the width of the slice, and the extra records are
appended to the vdata. So, to append records to vdata &#8216;vd&#8217;, simply
assign records to the slice &#8216;vd[vd._nrecs:]&#8217;. Note that, even if the
&#8216;field&#8217; dimension can be specified in the left-hand side expression,
there is no real interest in doing so, since all fields must
be specified when assigning a record to the vdata: it is an error to
try to assign just a few of the fields.</p>
<p>For example, given a vdata &#8216;vd&#8217; holding 5 records, and lists &#8216;reca&#8217;,
&#8216;recb&#8217;, etc, holding record values:</p>
<blockquote>
<div>vd[0] = reca              # updates record 0
vd[0,:] = reca            # specifying fields is OK, but useless
vd[0,1:] = reca[1:]       # error: all fields must be assigned
vd[1] = [recb, recc]      # error: only one record allowed
vd[5] = recc              # append one record
vd[1:3] = [reca,recb]     # updates second and third record
vd[1:4] = [reca, recb]    # error: 3 records needed
vd[5:] = [reca,recb]      # appends 2 records to the vdata
vd[4:] = [reca, recb]     # updates last record, append one</div></blockquote>
</div>
<div class="section" id="programming-models">
<h1>Programming models<a class="headerlink" href="#programming-models" title="Permalink to this headline">¶</a></h1>
</div>
<div class="section" id="creating-and-initializing-a-new-vdata">
<h1>Creating and initializing a new vdata<a class="headerlink" href="#creating-and-initializing-a-new-vdata" title="Permalink to this headline">¶</a></h1>
<p>The following code can serve as a model for the creation and
initialization of a new vdata. It implements the INVENTORY example
described in the &#8220;Introduction&#8221; section.</p>
<blockquote>
<div><p>from pyhdf.HDF import *
from pyhdf.VS import *</p>
<p># Open HDF file and initialize the VS interface
f = HDF(&#8216;inventory.hdf&#8217;,    # Open file &#8216;inventory.hdf&#8217; in write mode</p>
<blockquote>
<div>HC.WRITE|HC.CREATE) # creating it if it does not exist</div></blockquote>
<p>vs = f.vstart()             # init vdata interface</p>
<p># Create vdata and define its structure
vd = vs.create(             # create a new vdata</p>
<blockquote>
<div><blockquote>
<div><dl class="docutils">
<dt>&#8216;INVENTORY&#8217;, # name of the vdata</dt>
<dd># fields of the vdata follow</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>((&#8216;partid&#8217;,HC.CHAR8, 5),       # 5 char string</dt>
<dd>(&#8216;description&#8217;,HC.CHAR8, 10), # 10 char string field
(&#8216;qty&#8217;,HC.INT16, 1),          # 1 16 bit int field
(&#8216;wght&#8217;,HC.FLOAT32, 1),       # 1 32 bit float
(&#8216;price&#8217;,HC.FLOAT32,1)        # 1 32 bit float</dd>
</dl>
<p>))         # 5 fields allocated in the vdata</p>
</div></blockquote>
<p># Set attributes on the vdata and its fields
vd.field(&#8216;wght&#8217;).unit = &#8216;lb&#8217;
vd.field(&#8216;price&#8217;).unit = &#8216;$&#8217;
# In order to be able to update a string attribute, it must
# always be set to the same length. This sets &#8216;status&#8217; to a 20
# char long, left-justified string, padded with spaces on the right.
vd.status = &#8220;%-20s&#8221; % &#8216;phase 1 done&#8217;</p>
<p># Store records
vd.write((                # write 3 records</p>
<blockquote>
<div>(&#8216;Q1234&#8217;, &#8216;bolt&#8217;,12, 0.01, 0.05),   # record 1
(&#8216;B5432&#8217;, &#8216;brush&#8217;, 10, 0.4, 4.25),  # record 2
(&#8216;S7613&#8217;, &#8216;scissor&#8217;, 2, 0.2, 3.75)  # record 3
))</div></blockquote>
<p>vd.detach()               # &#8220;close&#8221; the vdata</p>
<p>vs.end()                  # terminate the vdata interface
f.close()                 # close the HDF file</p>
</div></blockquote>
<p>Note that is mandatory to always write whole records to the vdata.
Note also the comments about the initialization of the &#8216;status&#8217;
vdata attribute. We want to be able update this attribute (see
following examples). However, the VS API  prohibits changing an attribute
type when updating its value. Since the length (order) of an attribute
is part of its type, we make sure of setting the attribute to a length
long enough to accomodate the longest possible string we migh want to
assign to the attribute.</p>
</div>
<div class="section" id="appending-records-to-a-vdata">
<h1>Appending records to a vdata<a class="headerlink" href="#appending-records-to-a-vdata" title="Permalink to this headline">¶</a></h1>
<p>Appending records requires first seeking to the end of the vdata, to avoid
overwriting existing records. The following code can serve as a model. The
INVENTORY vdata created before is used.</p>
<blockquote>
<div><p>from pyhdf.HDF import *
from pyhdf.VS import *</p>
<dl class="docutils">
<dt>f = HDF(&#8216;inventory.hdf&#8217;,         # Open &#8216;inventory.hdf&#8217; in write mode</dt>
<dd>HC.WRITE|HC.CREATE)      # creating it if it does not exist</dd>
</dl>
<p>vs = f.vstart()                  # init vdata interface
vd = vs.attach(&#8216;INVENTORY&#8217;, 1)   # attach &#8216;INVENTORY&#8217; in write mode</p>
<p># Update the <a href="#id1"><span class="problematic" id="id2">`</span></a>status&#8217; vdata attribute. The attribute length must not
# change. We call the attribute info() method, which returns a list
# where number of values (eg string length) is stored at index 2.
# We then assign a left justified string of exactly that length.
len = vd.attr(&#8216;status&#8217;).info()[2]
vd.status = &#8216;%-<a href="#id3"><span class="problematic" id="id4">*</span></a>s&#8217; % (len, &#8216;phase 2 done&#8217;)</p>
<dl class="docutils">
<dt>vd[vd._nrecs:] = (                     # append 2 records</dt>
<dd><p class="first">(&#8216;A4321&#8217;, &#8216;axe&#8217;, 5, 1.5, 25),    # first record
(&#8216;C3214&#8217;, &#8216;cup&#8217;, 100, 0.1, 3.25) # second record</p>
<blockquote class="last">
<div>)</div></blockquote>
</dd>
</dl>
<p>vd.detach()               # &#8220;close&#8221; the vdata</p>
<p>vs.end()                  # terminate the vdata interface
f.close()                 # close the HDF file</p>
</div></blockquote>
<p>Note how, when updating the value of the &#8216;status&#8217; vdata attribute,
we take care of assigning a value of the same length as that of the
original value. Otherwise, the assignment would raise an exception.
Records are written by assigning the vdata through a slicing
expression, like a python sequence. By specifying the number of records
as the start of the slice, the records are appended to the vdata.</p>
</div>
<div class="section" id="updating-records-in-a-vdata">
<h1>Updating records in a vdata<a class="headerlink" href="#updating-records-in-a-vdata" title="Permalink to this headline">¶</a></h1>
<p>Updating requires seeking to the record to update before writing the new
records. New data will overwrite this record and all records that follow,
until a new seek is performed or the vdata is closed. Note that record
numbering starts at 0.</p>
<p>The following code can serve as a model. The INVENTORY vdata created
before is used.</p>
<blockquote>
<div><p>from pyhdf.HDF import *
from pyhdf.VS import *</p>
<dl class="docutils">
<dt>f = HDF(&#8216;inventory.hdf&#8217;,         # Open &#8216;inventory.hdf&#8217; in write mode</dt>
<dd>HC.WRITE|HC.CREATE)      # creating it if it does not exist</dd>
</dl>
<p>vs = f.vstart()                  # init vdata interface
vd = vs.attach(&#8216;INVENTORY&#8217;, 1)   # attach &#8216;INVENTORY&#8217; in write mode</p>
<p># Update the <a href="#id5"><span class="problematic" id="id6">`</span></a>status&#8217; vdata attribute. The attribute length must not
# change. We call the attribute info() method, which returns a list
# where number of values (eg string length) is stored at index 2.
# We then assign a left justified string of exactly that length.
len = vd.attr(&#8216;status&#8217;).info()[2]
vd.status = &#8216;%-<a href="#id7"><span class="problematic" id="id8">*</span></a>s&#8217; % (len, &#8216;phase 3 done&#8217;)</p>
<p># Update record at index 1 (second record)
vd[1]  = (&#8216;Z4367&#8217;, &#8216;surprise&#8217;, 10, 3.1, 44.5)
# Update record at index 4, and all those that follow
vd[4:] = (</p>
<blockquote>
<div>(&#8216;QR231&#8217;, &#8216;toy&#8217;, 12, 2.5, 45),
(&#8216;R3389&#8217;, &#8216;robot&#8217;, 3, 45, 2000)
)</div></blockquote>
<p>vd.detach()               # &#8220;close&#8221; the vdata
vs.end()                  # terminate the vdata interface
f.close()                 # close the HDF file</p>
</div></blockquote>
</div>
<div class="section" id="reading-a-vdata">
<h1>Reading a vdata<a class="headerlink" href="#reading-a-vdata" title="Permalink to this headline">¶</a></h1>
<p>The following example shows how read the vdata attributes and sequentially
maneuver through its records. Note how we use the exception mechanism 
to break out of the reading loop when we reach the end of the vdata.</p>
<blockquote>
<div><p>from pyhdf.HDF import *
from pyhdf.VS import *</p>
<p>f = HDF(&#8216;inventory.hdf&#8217;)         # open &#8216;inventory.hdf&#8217; in read mode
vs = f.vstart()                  # init vdata interface
vd = vs.attach(&#8216;INVENTORY&#8217;)      # attach &#8216;INVENTORY&#8217; in read mode</p>
<p># Display some vdata attributes
print &#8220;status:&#8221;, vd.status
print &#8220;vdata: &#8221;, vd._name        # predefined attribute: vdata name
print &#8220;nrecs: &#8221;, vd._nrecs       # predefined attribute:  num records</p>
<p># Display value of attribute &#8216;unit&#8217; for all fields on which
# this attribute is set
print &#8220;units: &#8221;,
for fieldName in vd._fields:     # loop over all field names</p>
<blockquote>
<div><dl class="docutils">
<dt>try:</dt>
<dd># instantiate field and obtain value of attribute &#8216;unit&#8217;
v = vd.field(fieldName).unit    
print &#8220;%s: %s&#8221; % (fieldName, v),</dd>
<dt>except:                      # no &#8216;unit&#8217; attribute: ignore </dt>
<dd>pass</dd>
</dl>
</div></blockquote>
<p>print &#8220;&#8221;
print &#8220;&#8221;</p>
<p># Display table header.
header = &#8220;%-7s %-12s %3s %4s %8s&#8221; % tuple(vd._fields)
print &#8220;-&#8221; * len(header)
print header
print &#8220;-&#8221; * len(header)</p>
<p># Loop over the vdata records, displaying each record as a table row.
# Current record position is 0 after attaching the vdata.
while 1:</p>
<blockquote>
<div><dl class="docutils">
<dt>try:</dt>
<dd><blockquote class="first">
<div>rec = vd.read()       # read next record
# equivalent to:</div></blockquote>
<dl class="last docutils">
<dt># rec = vd[vd.tell()]</dt>
<dd>print &#8220;%-7s %-12s %3d %4.1f %8.2f&#8221; % tuple(rec[0])</dd>
</dl>
</dd>
<dt>except HDF4Error:             # end of vdata reached</dt>
<dd>break</dd>
</dl>
</div></blockquote>
<p>vd.detach()               # &#8220;close&#8221; the vdata
vs.end()                  # terminate the vdata interface
f.close()                 # close the HDF file</p>
</div></blockquote>
<p>In the previous example, the reading/displaying loop can be greatly
simplified by rewriting it as follows:</p>
<blockquote>
<div><p>from pyhdf.HDF import *
from pyhdf.VS import *</p>
<p>f = HDF(&#8216;inventory.hdf&#8217;)         # open &#8216;inventory.hdf&#8217; in read mode
vs = f.vstart()                  # init vdata interface
vd = vs.attach(&#8216;INVENTORY&#8217;)      # attach &#8216;INVENTORY&#8217; in read mode</p>
<p># Read all records at once, and loop over the sequence.
for rec in vd[:]:</p>
<blockquote>
<div>print &#8220;%-7s %-12s %3d %4.1f %8.2f&#8221; % tuple(rec)</div></blockquote>
<p>vd.detach()               # &#8220;close&#8221; the vdata
...</p>
</div></blockquote>
<p>The indexing expression &#8216;vd[:]&#8217; returns the complete set of records,
which can then be looped over using a &#8216;for&#8217; statement. This style of loop
is quite clean, and should look very familiar to python adepts.</p>
<dl class="class">
<dt id="pyhdf.VS.VS">
<em class="property">class </em><tt class="descclassname">pyhdf.VS.</tt><tt class="descname">VS</tt><big>(</big><em>hinst</em><big>)</big><a class="headerlink" href="#pyhdf.VS.VS" title="Permalink to this definition">¶</a></dt>
<dd><p>The VS class implements the VS (Vdata) interface applied to an
HDF file.
To instantiate a VS class, call the vstart() method of an
HDF instance.</p>
<dl class="method">
<dt id="pyhdf.VS.VS.attach">
<tt class="descname">attach</tt><big>(</big><em>num_name</em>, <em>write=0</em><big>)</big><a class="headerlink" href="#pyhdf.VS.VS.attach" title="Permalink to this definition">¶</a></dt>
<dd><p>Locate an existing vdata or create a new vdata in the HDF file,
returning a VD instance.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>num_name  Name or reference number of the vdata. An existing vdata</dt>
<dd>can be specified either through its reference number or
its name. Use -1 to create a new vdata.
Note that uniqueness is not imposed on vdatas names,
whereas refnums are guaranteed to be unique. Thus
knowledge of its reference number may be the only way
to get at a wanted vdata.</dd>
<dt>write     Set to 0 to open the vdata in read-only mode,</dt>
<dd>set to 1 to open it in write mode</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>VD instance representing the vdata</dd>
</dl>
<p>C library equivalent : VSattach</p>
<p>After creating a new vdata (num_name == -1), fields must be
defined using method fdefine() of the VD instance, and those
fields must be allocated to the vdata with method setfields().
Same results can be achieved, but more simply, by calling the
create() method of the VS instance.</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.VS.VS.create">
<tt class="descname">create</tt><big>(</big><em>name</em>, <em>fields</em><big>)</big><a class="headerlink" href="#pyhdf.VS.VS.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new vdata, setting its name and allocating
its fields.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">name     Name to assign to the vdata
fields   Sequence of field definitions. Each field definition</p>
<blockquote class="last">
<div><dl class="docutils">
<dt>is a sequence with the following elements in order:</dt>
<dd>-field name
-field type (one of HC.xxx constants)
-field order (number of values)</dd>
</dl>
<p>Fields are allocated to the vdata in the given order</p>
</div></blockquote>
</dd>
<dt>Returns:</dt>
<dd>VD instance representing the created vdata</dd>
<dt>Calling the create() method is equivalent to the following calls:</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>vd = attach(-1,1), to create a new vdata and open it in</dt>
<dd><p class="first last">write mode</p>
</dd>
</dl>
</li>
<li><p class="first">vd._name = name, to set the vdata name</p>
</li>
<li><dl class="first docutils">
<dt>vd.fdefine(...), to define the name, type and order of</dt>
<dd><p class="first last">each field</p>
</dd>
</dl>
</li>
<li><p class="first">vd.setfields(...), to allocate fields to the vdata</p>
</li>
</ul>
</dd>
</dl>
<p>C library equivalent : no equivalent</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.VS.VS.end">
<tt class="descname">end</tt><big>(</big><big>)</big><a class="headerlink" href="#pyhdf.VS.VS.end" title="Permalink to this definition">¶</a></dt>
<dd><p>Close the VS interface.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>No argument</dd>
<dt>Returns:</dt>
<dd>None</dd>
</dl>
<p>C library equivalent : Vend</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.VS.VS.find">
<tt class="descname">find</tt><big>(</big><em>vName</em><big>)</big><a class="headerlink" href="#pyhdf.VS.VS.find" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the reference number of a vdata given its name.
The vdata can then be opened (attached) by passing this
reference number to the attach() method.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>vName    Name of the vdata for which the reference number</dt>
<dd>is needed. vdatas names are not guaranteed to be
unique. When more than one vdata bear the same name,
find() will return the refnum of the first one founmd.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>vdata reference number. 0 is returned if the vdata does not exist.</dd>
</dl>
<p>C library equivalent : VSfind</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.VS.VS.next">
<tt class="descname">next</tt><big>(</big><em>vRef</em><big>)</big><a class="headerlink" href="#pyhdf.VS.VS.next" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the reference number of the vdata following a given
vdata.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>vRef   Reference number of the vdata preceding the one</dt>
<dd>we require. Set to -1 to get the first vdata in
the HDF file. Knowing its reference number,
the vdata can then be opened (attached) by passing this
reference number to the attach() method.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>Reference number of the vdata following the one given
by argument vref</dd>
</dl>
<p>An exception is raised if no vdata follows the one given by vRef.</p>
<p>C library equivalent : VSgetid</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.VS.VS.storedata">
<tt class="descname">storedata</tt><big>(</big><em>fieldName</em>, <em>values</em>, <em>data_type</em>, <em>vName</em>, <em>vClass</em><big>)</big><a class="headerlink" href="#pyhdf.VS.VS.storedata" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and initialize a single field vdata, returning
the vdata reference number.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">fieldName   Name of the single field in the vadata to create
values      Sequence of values to store in the field;. Each value can</p>
<blockquote>
<div>itself be a sequence, in which case the field will be
multivalued (all second-level sequences must be of
the same length)</div></blockquote>
<dl class="docutils">
<dt>data_type   Values type (one of HC.xxx constants). All values</dt>
<dd>must be of the same type</dd>
</dl>
<p class="last">vName       Name of the vdata to create
vClass      Vdata class (string)</p>
</dd>
<dt>Returns:</dt>
<dd>vdata reference number</dd>
</dl>
<p>C library equivalent : VHstoredata / VHstoredatam</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.VS.VS.vdatainfo">
<tt class="descname">vdatainfo</tt><big>(</big><em>listAttr=0</em><big>)</big><a class="headerlink" href="#pyhdf.VS.VS.vdatainfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Return info about all the file vdatas.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>listAttr   Set to 0 to ignore vdatas used to store attribute</dt>
<dd>values, 1 to list them (see the VD._isattr readonly
attribute)</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><p class="first">List of vdata descriptions. Each vdata is described as
a 9-element tuple, composed of the following:</p>
<blockquote class="last">
<div>-vdata name
-vdata class
-vdata reference number
-vdata number of records
-vdata number of fields
-vdata number of attributes
-vdata record size in bytes
-vdata tag number
-vdata interlace mode</div></blockquote>
</dd>
</dl>
<p>C library equivalent : no equivalent</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.VS.VS.vend">
<tt class="descname">vend</tt><big>(</big><big>)</big><a class="headerlink" href="#pyhdf.VS.VS.vend" title="Permalink to this definition">¶</a></dt>
<dd><p>Close the VS interface.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>No argument</dd>
<dt>Returns:</dt>
<dd>None</dd>
</dl>
<p>C library equivalent : Vend</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyhdf.VS.VD">
<em class="property">class </em><tt class="descclassname">pyhdf.VS.</tt><tt class="descname">VD</tt><big>(</big><em>vsinst</em>, <em>id</em><big>)</big><a class="headerlink" href="#pyhdf.VS.VD" title="Permalink to this definition">¶</a></dt>
<dd><p>The VD class encapsulates the functionnality of a vdata.
To instantiate a VD class, call the attach() or the create()
method of a VS class instance.</p>
<dl class="method">
<dt id="pyhdf.VS.VD.attr">
<tt class="descname">attr</tt><big>(</big><em>name_or_index</em><big>)</big><a class="headerlink" href="#pyhdf.VS.VD.attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a VDAttr instance representing a vdata attribute.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>name_or_index   attribute name or index number; if a name is</dt>
<dd>given, the attribute may not exist; in that
case, it will be created when the VSAttr
instance set() method is called</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>VSAttr instance for the attribute. Call the methods of this
class to query, read or set the attribute.</dd>
</dl>
<p>C library equivalent : no equivalent</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.VS.VD.attrinfo">
<tt class="descname">attrinfo</tt><big>(</big><big>)</big><a class="headerlink" href="#pyhdf.VS.VD.attrinfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Return info about all the vdata attributes.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>no argument</dd>
<dt>Returns:</dt>
<dd><p class="first">dictionnary describing each vdata attribute; for each attribute
a (name,data) pair is added to the dictionary, where &#8216;data&#8217; is
a tuple holding:</p>
<blockquote class="last">
<div>-attribute data type (one of HC.xxx constants)
-attribute order
-attribute value
-attribute size in bytes</div></blockquote>
</dd>
</dl>
<p>C library equivalent : no equivalent</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.VS.VD.detach">
<tt class="descname">detach</tt><big>(</big><big>)</big><a class="headerlink" href="#pyhdf.VS.VD.detach" title="Permalink to this definition">¶</a></dt>
<dd><p>Terminate access to the vdata.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>no argument</dd>
<dt>Returns:</dt>
<dd>None</dd>
</dl>
<p>C library equivalent : VSdetach</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.VS.VD.fdefine">
<tt class="descname">fdefine</tt><big>(</big><em>name</em>, <em>type</em>, <em>order</em><big>)</big><a class="headerlink" href="#pyhdf.VS.VD.fdefine" title="Permalink to this definition">¶</a></dt>
<dd><p>Define a field. To initialize a newly created vdata with
fields created with fdefine(), assign a tuple of field names
to the _fields attribute or call the setfields() method.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>name     field name
type     field data type (one of HC.xxx)
order    field order (number of values in the field)</dd>
<dt>Returns:</dt>
<dd>None</dd>
</dl>
<p>C library equivalent : VSfdefine</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.VS.VD.fexist">
<tt class="descname">fexist</tt><big>(</big><em>fields</em><big>)</big><a class="headerlink" href="#pyhdf.VS.VD.fexist" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if a vdata contains a given set of fields.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>fields   sequence of field names whose presence in the</dt>
<dd>vdata must be checked</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>true  (1) if the given fields are present
false (0) otherwise</dd>
</dl>
<p>C library equivalent : VSfexist</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.VS.VD.field">
<tt class="descname">field</tt><big>(</big><em>name_index</em><big>)</big><a class="headerlink" href="#pyhdf.VS.VD.field" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a VDField instance representing a field of the vdata.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>name_index   name or index number of the field</dd>
<dt>Returns:</dt>
<dd>VDfield instance representing the field</dd>
</dl>
<p>C library equivalent : no equivalent</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.VS.VD.fieldinfo">
<tt class="descname">fieldinfo</tt><big>(</big><big>)</big><a class="headerlink" href="#pyhdf.VS.VD.fieldinfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve info about all vdata fields.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>no argument</dd>
<dt>Returns:</dt>
<dd><p class="first">list where each element describes a field of the vdata;
each field is described by an 7-element tuple containing
the following elements:</p>
<blockquote class="last">
<div>-field name
-field data type (one of HC.xxx constants)
-field order
-number of attributes attached to the field
-field index number
-field external size
-field internal size</div></blockquote>
</dd>
</dl>
<p>C library equivalent : no equivalent</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.VS.VD.findattr">
<tt class="descname">findattr</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#pyhdf.VS.VD.findattr" title="Permalink to this definition">¶</a></dt>
<dd><p>Search the vdata for a given attribute.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>name    attribute name</dd>
<dt>Returns:</dt>
<dd><blockquote class="first">
<div>if found, VDAttr instance describing the attribute
None otherwise</div></blockquote>
<p class="last">C library equivalent : VSfindattr</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyhdf.VS.VD.inquire">
<tt class="descname">inquire</tt><big>(</big><big>)</big><a class="headerlink" href="#pyhdf.VS.VD.inquire" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve info about the vdata.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>no argument</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>5-element tuple with the following elements:</dt>
<dd>-number of records in the vdata
-interlace mode
-list of vdata field names
-size in bytes of the vdata record
-name of the vdata</dd>
</dl>
</dd>
</dl>
<p>C library equivalent : VSinquire</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.VS.VD.read">
<tt class="descname">read</tt><big>(</big><em>nRec=1</em><big>)</big><a class="headerlink" href="#pyhdf.VS.VD.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the values of a number of records, starting
at the current record position. The current record position
is advanced by the number of records read. Current position
is 0 after &#8220;opening&#8221; the vdata with the attach() method.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>nRec    number of records to read</dd>
<dt>Returns:</dt>
<dd>2-level list. First level is a sequence of records,
second level gives the sequence of values for each record.
The values returned for each record are those of the fields
specified in the last call to method setfields(), in that
order. The complete vdata field set is returned if
setfields() has not been called.</dd>
</dl>
<p>An exception is raised if the current record position is
already at the end of the vdata when read() is called. This
exception can be caught as an &#8220;end of vdata&#8221; indication to
exit a loop which scans each record of the vdata. Otherwise,
the number of records to be read is lowered to the number of
records remaining in the vdata, if that number is less than
the number asked for by parameter &#8216;nRec&#8217;. Setting &#8216;nRec&#8217; to
an arbitrarily large value can thus be used to retrieve the
remaining records in the vdata.</p>
<p>C library equivalent : VSread</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.VS.VD.seek">
<tt class="descname">seek</tt><big>(</big><em>recIndex</em><big>)</big><a class="headerlink" href="#pyhdf.VS.VD.seek" title="Permalink to this definition">¶</a></dt>
<dd><p>Seek to the beginning of the record identified by its
record index. A succeeding read will load this record in
memory.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>recIndex  index of the record in the vdata; numbering</dt>
<dd>starts at 0. Legal values range from 0
(start of vdata) to the current number of
records (at end of vdata).</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>record index</dd>
</dl>
<p>An exception is raised if an attempt is made to seek beyond the
last record.</p>
<p>The C API prohibits seeking past the next-to-last record,
forcing one to read the last record to advance to the end
of the vdata. The python API removes this limitation.</p>
<p>Seeking to the end of the vdata can also be done by calling
method <a href="#id9"><span class="problematic" id="id10">`</span></a>seekend()&#8217;.</p>
<p>C library equivalent : VSseek</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.VS.VD.seekend">
<tt class="descname">seekend</tt><big>(</big><big>)</big><a class="headerlink" href="#pyhdf.VS.VD.seekend" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the current record position past the last vdata record.
Subsequent write() calls will append records to the vdata.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>no argument</dd>
<dt>Returns:</dt>
<dd>index of the last record plus 1</dd>
</dl>
<p>C library equivalent : no equivalent</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.VS.VD.setfields">
<tt class="descname">setfields</tt><big>(</big><em>*fldNames</em><big>)</big><a class="headerlink" href="#pyhdf.VS.VD.setfields" title="Permalink to this definition">¶</a></dt>
<dd><p>Define the name and order of the fields to access
with the read() and write() methods.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>fldNames  variable length argument specifying one or more</dt>
<dd>vdata field names</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>None</dd>
</dl>
<p>C library equivalent : VSsetfields</p>
<p>setfields() indicates how to perform the matching between the vdata
fields and the values passed to the write() method or returned
by the read() method.</p>
<p>For example, if the vdata contains fields &#8216;a&#8217;, &#8216;b&#8217; and &#8216;c&#8217; and
a &#8220;setfields(&#8216;c&#8217;,&#8217;a&#8217;)&#8221; call is made,  read() will thereafter return
for each record the values of field &#8216;c&#8217; and &#8216;a&#8217;, in that order.
Field &#8216;b&#8217; will be ignored.</p>
<p>When writing to a vdata, setfields() has a second usage. It is used
to initialize the structure of the vdata, that is, the name and order
of the fields that it will contain. The fields must have been
previously defined by calls to the fdefine() method.
Following that first call, setfields() can be called again to
change the order in which the record values will be passed
to the write() method. However, since it is mandatory to write
whole records, subsequent calls to setfields() must specify every
field name: only the field order can be changed.</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.VS.VD.sizeof">
<tt class="descname">sizeof</tt><big>(</big><em>fields</em><big>)</big><a class="headerlink" href="#pyhdf.VS.VD.sizeof" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the size in bytes of the given fields.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>fields   sequence of field names to query</dd>
<dt>Returns:</dt>
<dd>total size of the fields in bytes</dd>
</dl>
<p>C library equivalent : VSsizeof</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.VS.VD.tell">
<tt class="descname">tell</tt><big>(</big><big>)</big><a class="headerlink" href="#pyhdf.VS.VD.tell" title="Permalink to this definition">¶</a></dt>
<dd><p>Return current record position in the vdata.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>no argument</dd>
<dt>Returns:</dt>
<dd>current record position; 0 is at start of vdata.</dd>
</dl>
<p>C library equivalent : no equivalent</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.VS.VD.write">
<tt class="descname">write</tt><big>(</big><em>values</em><big>)</big><a class="headerlink" href="#pyhdf.VS.VD.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write records to the vdata. Writing starts at the current
record position, which is advanced by the number of records
written.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>values: 2-level sequence. First level is a sequence of records.</dt>
<dd>A second level gives the sequence of record values.
It is mandatory to always write whole records. Thus
every record field must appear at the second level.
The record values are ordered according the list of
field names set in the last call to the setfields()
method. The ordre of the complete vdata field set is
used if setfields() has not been called.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>number of records written</dd>
</dl>
<p>To append to a vdata already holding &#8216;n&#8217; records, it is necessary
to first move the current record position to &#8216;n-1&#8217; with a call to
method seek(), then to call method read() for the side effect
of advancing the current record position past this last record.
Method seekend() does just that.</p>
<p>C library equivalent : VSwrite</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyhdf.VS.VDField">
<em class="property">class </em><tt class="descclassname">pyhdf.VS.</tt><tt class="descname">VDField</tt><big>(</big><em>vdinst</em>, <em>fIndex</em><big>)</big><a class="headerlink" href="#pyhdf.VS.VDField" title="Permalink to this definition">¶</a></dt>
<dd><p>The VDField class represents a vdata field.
To create a VDField instance, call the field() method of a
VD class instance.</p>
<dl class="method">
<dt id="pyhdf.VS.VDField.attr">
<tt class="descname">attr</tt><big>(</big><em>name_or_index</em><big>)</big><a class="headerlink" href="#pyhdf.VS.VDField.attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a VDAttr instance representing a field attribute.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>name_or_index   attribute name or index number; if a name is</dt>
<dd>specified, the attribute may not exist; in that
case, it will be created when the VDAttr
instance set() method is called; if an
index number is specified, the attribute
must exist</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>VSAttr instance for the attribute. Call the methods of this
class to query, read or set the attribute.</dd>
</dl>
<p>C library equivalent : no equivalent</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.VS.VDField.attrinfo">
<tt class="descname">attrinfo</tt><big>(</big><big>)</big><a class="headerlink" href="#pyhdf.VS.VDField.attrinfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Return info about all the field attributes.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>no argument</dd>
<dt>Returns:</dt>
<dd><p class="first">dictionnary describing each vdata attribute; for each attribute
a (name,data) pair is added to the dictionary, where &#8216;data&#8217; is
a tuple holding:</p>
<blockquote class="last">
<div>-attribute data type (one of HC.xxx constants)
-attribute order
-attribute value
-attribute size in bytes</div></blockquote>
</dd>
</dl>
<p>C library equivalent : no equivalent</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.VS.VDField.find">
<tt class="descname">find</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#pyhdf.VS.VDField.find" title="Permalink to this definition">¶</a></dt>
<dd><p>Search the field for a given attribute.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>name    attribute name</dd>
<dt>Returns:</dt>
<dd><blockquote class="first">
<div>if found, VDAttr instance describing the attribute
None otherwise</div></blockquote>
<p class="last">C library equivalent : VSfindattr</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyhdf.VS.VDAttr">
<em class="property">class </em><tt class="descclassname">pyhdf.VS.</tt><tt class="descname">VDAttr</tt><big>(</big><em>obj</em>, <em>name_or_index</em>, <em>fIndex</em><big>)</big><a class="headerlink" href="#pyhdf.VS.VDAttr" title="Permalink to this definition">¶</a></dt>
<dd><p>The VDAttr class encapsulates methods used to set and query attributes
defined at the level either of the vdata or of the vdata field.
To create an instance of this class, call the attr() method of a VD
(vdata) or VDField (vdata field) instance.</p>
<dl class="method">
<dt id="pyhdf.VS.VDAttr.get">
<tt class="descname">get</tt><big>(</big><big>)</big><a class="headerlink" href="#pyhdf.VS.VDAttr.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the attribute value.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>no argument</dd>
<dt>Returns: </dt>
<dd>attribute value(s); a list is returned if the attribute
is made up of more than one value, except in the case of a 
string-valued attribute (data type HC.CHAR8) where the 
values are returned as a string</dd>
</dl>
<p>C library equivalent : VSgetattr</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.VS.VDAttr.info">
<tt class="descname">info</tt><big>(</big><big>)</big><a class="headerlink" href="#pyhdf.VS.VDAttr.info" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve info about the attribute.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>no argument</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>4-element tuple with the following components:</dt>
<dd>-attribute name
-attribute data type (one of HC.xxx constants)
-attribute order (number of values)
-attribute size in bytes</dd>
</dl>
</dd>
</dl>
<p>C library equivalent : VSattrinfo</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.VS.VDAttr.set">
<tt class="descname">set</tt><big>(</big><em>data_type</em>, <em>values</em><big>)</big><a class="headerlink" href="#pyhdf.VS.VDAttr.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the attribute value.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">data_type    : attribute data type (see constants HC.xxx)
values       : attribute value(s); specify a list to create</p>
<blockquote class="last">
<div><p>a multi-valued attribute; a string valued
attribute can be created by setting &#8216;data_type&#8217;
to HC.CHAR8 and &#8216;values&#8217; to the corresponding
string</p>
<p>If the attribute already exists, it will be
updated. However, it is illegal to try to change
its data type or its order (number of values).</p>
</div></blockquote>
</dd>
<dt>Returns: </dt>
<dd>None</dd>
</dl>
<p>C library equivalent : VSsetattr</p>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Table of contents</a></li>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#vs-module-key-features">VS module key features</a></li>
<li><a class="reference internal" href="#accessing-the-vs-module">Accessing the VS module</a></li>
<li><a class="reference internal" href="#package-components">Package components</a></li>
<li><a class="reference internal" href="#prerequisites">Prerequisites</a></li>
<li><a class="reference internal" href="#documentation">Documentation</a></li>
<li><a class="reference internal" href="#summary-of-differences-between-the-pyhdf-and-c-vs-api">Summary of differences between the pyhdf and C VS API</a></li>
<li><a class="reference internal" href="#error-handling">Error handling</a></li>
<li><a class="reference internal" href="#vs-needs-support-from-the-hdf-module">VS needs support from the HDF module</a></li>
<li><a class="reference internal" href="#classes-summary">Classes summary</a></li>
<li><a class="reference internal" href="#data-types">Data types</a></li>
<li><a class="reference internal" href="#attribute-access-low-and-high-level">Attribute access: low and high level</a></li>
<li><a class="reference internal" href="#predefined-attributes">Predefined attributes</a></li>
<li><a class="reference internal" href="#record-access-low-and-high-level">Record access: low and high level</a></li>
<li><a class="reference internal" href="#programming-models">Programming models</a></li>
<li><a class="reference internal" href="#creating-and-initializing-a-new-vdata">Creating and initializing a new vdata</a></li>
<li><a class="reference internal" href="#appending-records-to-a-vdata">Appending records to a vdata</a></li>
<li><a class="reference internal" href="#updating-records-in-a-vdata">Updating records in a vdata</a></li>
<li><a class="reference internal" href="#reading-a-vdata">Reading a vdata</a></li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="SD.html"
                        title="previous chapter">Table of contents</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="V.html"
                        title="next chapter">Table of contents</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/modules/VS.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="V.html" title="Table of contents"
             >next</a> |</li>
        <li class="right" >
          <a href="SD.html" title="Table of contents"
             >previous</a> |</li>
        <li><a href="../index.html">pyhdf 0.9 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, pyhdf authors.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>