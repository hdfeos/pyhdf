<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Table of contents &mdash; pyhdf 0.9 documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.9',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="pyhdf 0.9 documentation" href="../index.html" />
    <link rel="prev" title="Table of contents" href="VS.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="VS.html" title="Table of contents"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">pyhdf 0.9 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <span class="target" id="module-pyhdf.V"></span><p>A module of the pyhdf package implementing the V (Vgroup)
API of the NCSA HDF4 library.
(see: hdf.ncsa.uiuc.edu)</p>
<dl class="docutils">
<dt>Author: Andre Gosselin</dt>
<dd>Maurice-Lamontagne Institute
<a class="reference external" href="mailto:gosselina&#37;&#52;&#48;dfo-mpo&#46;gc&#46;ca">gosselina<span>&#64;</span>dfo-mpo<span>&#46;</span>gc<span>&#46;</span>ca</a></dd>
</dl>
<p>Version: 0.7-3
Date:    july 13 2005</p>
<div class="section" id="table-of-contents">
<h1>Table of contents<a class="headerlink" href="#table-of-contents" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div><p>Introduction
Accessing the V module
Package components
Prerequisites
Summary of differences between the pyhdf and C V API
Error handling
V needs support from the HDF module
Classes summary
Attribute access: low and high level
Predefined attributes
Programming models</p>
<p>Module documentation</p>
</div></blockquote>
</div>
<div class="section" id="introduction">
<h1>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h1>
<p>V is one of the modules composing pyhdf, a python package implementing
the NCSA HDF library and letting one manage HDF files from within a python
program. Two versions of the HDF library currently exist, version 4 and
version 5. pyhdf only implements version 4 of the library. Many
different APIs are to be found inside the HDF4 specification.
Currently, pyhdf implements just a few of those: the SD, VS and V APIs.
Other APIs should be added in the future (GR, AN, etc).</p>
<p>The V API supports the definition of vgroups inside an HDF file. A vgroup
can thought of as a collection of arbitrary &#8220;references&#8221; to other HDF
objects defined in the same file. A vgroup may hold references to
other vgroups. It is thus possible to organize HDF objects into some sort
of a hierarchy, similar to files grouped into a directory tree under unix.
This vgroup hierarchical nature partly explains the origin of the &#8220;HDF&#8221;
name (Hierarchical Data Format). vgroups can help logically organize the
contents of an HDF file, for example by grouping together all the datasets
belonging to a given experiment, and subdividing those datasets according
to the day of the experiment, etc.</p>
<p>The V API provides functions to find and access an existing vgroup,
create a new one, delete a vgroup, identify the members of a vgroup, add
and remove members to and from a vgroup, and set and query attributes
on a vgroup. The members of a vgroup are identified through their tags
and reference numbers. Tags are constants identifying each main object type
(dataset, vdata, vgroup). Reference numbers serve to distinguish among
objects of the same type. To add an object to a vgroup, one must first
initialize that object using the API proper to that object type (eg: SD for
a dataset) so as to create a reference number for that object, and then
pass this reference number and the type tag to the V API. When reading the
contents of a vgroup, the V API returns the tags and reference numbers of
the objects composing the vgroup. The user program must then call the
proper API to process each object, based on tag of this object (eg: VS for
a tag identifying a vdata object).</p>
<p>Some limitations of the V API must be stressed. First, HDF imposes
no integrity constraint whatsoever on the contents of a vgroup, nor does it
help maintain such integrity. For example, a vgroup is not strictly
hierarchical, because an object can belong to more than one vgroup. It would
be easy to create vgroups showing cycles among their members. Also, a vgroup
member is simply a reference to an HDF object. If this object is afterwards
deleted for any reason, the vgroup membership will not be automatically
updated. The vgroup will refer to a non-existent object and thus be left
in an inconsistent state. Nothing prevents adding the same member more than
once to a vgroup, and giving the same name to more than one vgroup.
Finally, the HDF library seems to make heavy use of vgroups for its own
internal needs, and creates vgroups &#8220;behind the scenes&#8221;. This may make it
difficult to pick up &#8220;user defined&#8221; vgroups when browsing an HDF file.</p>
</div>
<div class="section" id="accessing-the-v-module">
<h1>Accessing the V module<a class="headerlink" href="#accessing-the-v-module" title="Permalink to this headline">¶</a></h1>
<p>To access the V module a python program can say one of:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyhdf.V</span>           <span class="c"># must prefix names with &quot;pyhdf.V.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyhdf</span> <span class="kn">import</span> <span class="n">V</span>      <span class="c"># must prefix names with &quot;V.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyhdf.V</span> <span class="kn">import</span> <span class="o">*</span>    <span class="c"># names need no prefix</span>
</pre></div>
</div>
<p>This document assumes the last import style is used.</p>
<p>V is not self-contained, and needs functionnality provided by another
pyhdf module, namely the HDF module. This module must thus be imported
also:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">HDF</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
</div>
<div class="section" id="package-components">
<h1>Package components<a class="headerlink" href="#package-components" title="Permalink to this headline">¶</a></h1>
<p>pyhdf is a proper Python package, eg a collection of modules stored under
a directory whose name is that of the package and which stores an
__init__.py file. Following the normal installation procedure, this
directory will be &lt;python-lib&gt;/site-packages/pyhdf&#8217;, where &lt;python-lib&gt;
stands for the python installation directory.</p>
<p>For each HDF API exists a corresponding set of modules.</p>
<p>The following modules are related to the V API.</p>
<blockquote>
<div><dl class="docutils">
<dt>_hdfext   C extension module responsible for wrapping the HDF</dt>
<dd>C library for all python modules</dd>
<dt>hdfext    python module implementing some utility functions</dt>
<dd>complementing the _hdfext extension module</dd>
</dl>
<p>error     defines the HDF4Error exception
HDF       python module providing support to the V module
V         python module wrapping the V API routines inside</p>
<blockquote>
<div>an OOP framework</div></blockquote>
</div></blockquote>
<p>_hdfext and hdfext were generated using the SWIG preprocessor.
SWIG is however <em>not</em> needed to run the package. Those two modules
are meant to do their work in the background, and should never be called
directly. Only HDF and V should be imported by the user program.</p>
</div>
<div class="section" id="prerequisites">
<h1>Prerequisites<a class="headerlink" href="#prerequisites" title="Permalink to this headline">¶</a></h1>
<p>The following software must be installed in order for the V module to
work.</p>
<blockquote>
<div><dl class="docutils">
<dt>HDF (v4) library</dt>
<dd><p class="first">pyhdf does <em>not</em> include the HDF4 library, which must
be installed separately.</p>
<p class="last">HDF is available at:
&#8220;<a class="reference external" href="http://hdf.ncsa.uiuc.edu/obtain.html">http://hdf.ncsa.uiuc.edu/obtain.html</a>&#8221;.</p>
</dd>
</dl>
</div></blockquote>
<p>Numeric is also needed by the SD module. See the SD module documentation.</p>
</div>
<div class="section" id="summary-of-differences-between-the-pyhdf-and-c-v-api">
<h1>Summary of differences between the pyhdf and C V API<a class="headerlink" href="#summary-of-differences-between-the-pyhdf-and-c-v-api" title="Permalink to this headline">¶</a></h1>
<p>Most of the differences between the pyhdf and C V API can
be summarized as follows.</p>
<blockquote>
<div><dl class="docutils">
<dt>-In the C API, every function returns an integer status code, and values</dt>
<dd>computed by the function are returned through one or more pointers
passed as arguments.</dd>
<dt>-In pyhdf, error statuses are returned through the Python exception</dt>
<dd>mechanism, and values are returned as the method result. When the
C API specifies that multiple values are returned, pyhdf returns a 
sequence of values, which are ordered similarly to the pointers in the
C function argument list.</dd>
</dl>
</div></blockquote>
</div>
<div class="section" id="error-handling">
<h1>Error handling<a class="headerlink" href="#error-handling" title="Permalink to this headline">¶</a></h1>
<p>All errors reported by the C V API with a SUCCESS/FAIL error code
are reported by pyhdf using the Python exception mechanism.
When the C library reports a FAIL status, pyhdf raises an HDF4Error
exception (a subclass of Exception) with a descriptive message. 
Unfortunately, the C library is rarely informative about the cause of 
the error. pyhdf does its best to try to document the error, but most 
of the time cannot do more than saying &#8220;execution error&#8221;.</p>
</div>
<div class="section" id="v-needs-support-from-the-hdf-module">
<h1>V needs support from the HDF module<a class="headerlink" href="#v-needs-support-from-the-hdf-module" title="Permalink to this headline">¶</a></h1>
<p>The VS module is not self-contained (countrary to the SD module).
It requires help from the HDF module, namely:</p>
<blockquote>
<div><dl class="docutils">
<dt>-the HDF.HDF class to open and close the HDF file, and initialize the</dt>
<dd>V interface</dd>
<dt>-the HDF.HC class to provide different sorts of constants (opening modes,</dt>
<dd>data types, etc).</dd>
</dl>
</div></blockquote>
<p>A program wanting to access HDF vgroups will almost always need to execute
the following minimal set of calls:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyhdf.HDF</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyhdf.V</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdfFile</span> <span class="o">=</span> <span class="n">HDF</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">HC</span><span class="o">.</span><span class="n">xxx</span><span class="p">)</span><span class="c"># open HDF file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">hdfFile</span><span class="o">.</span><span class="n">vgstart</span><span class="p">()</span>      <span class="c"># initialize V interface on HDF file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">...</span>                        <span class="c"># manipulate vgroups</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>                    <span class="c"># terminate V interface</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hdfFile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>            <span class="c"># close HDF file</span>
</pre></div>
</div>
</div>
<div class="section" id="classes-summary">
<h1>Classes summary<a class="headerlink" href="#classes-summary" title="Permalink to this headline">¶</a></h1>
<p>pyhdf wraps the V API using the following python classes:</p>
<blockquote>
<div>V      HDF V interface
VG     vgroup
VGAttr vgroup attribute</div></blockquote>
<p>In more detail:</p>
<blockquote>
<div><dl class="docutils">
<dt>V     The V class implements the V (Vgroup) interface applied to an</dt>
<dd><p class="first">HDF file.</p>
<p>To instantiate a V class, call the vgstart() method of an
HDF instance.</p>
<dl class="last docutils">
<dt>methods:</dt>
<dd><dl class="first last docutils">
<dt>constructors</dt>
<dd><dl class="first last docutils">
<dt>attach()      open an existing vgroup given its name or its</dt>
<dd>reference number, or create a new vgroup,
returning a VG instance for that vgroup</dd>
<dt>create()      create a new vgroup, returning a VG instance</dt>
<dd>for that vgroup</dd>
</dl>
</dd>
<dt>closing the interface</dt>
<dd>end()         close the V interface on the HDF file</dd>
<dt>deleting a vgroup</dt>
<dd><dl class="first last docutils">
<dt>delete()      delete the vgroup identified by its name or</dt>
<dd>its reference number</dd>
</dl>
</dd>
<dt>searching</dt>
<dd><dl class="first last docutils">
<dt>find()        find a vgroup given its name, returning</dt>
<dd>the vgroup reference number</dd>
<dt>findclass()   find a vgroup given its class name, returning</dt>
<dd>the vgroup reference number</dd>
<dt>getid()       return the reference number of the vgroup</dt>
<dd>following the one with the given reference number</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>VG    The VG class encapsulates the functionnality of a vgroup.</p>
<blockquote>
<div><p>To instantiate a VG class, call the attach() or create() methods
of a V class instance.</p>
<blockquote>
<div><p>constructors</p>
<blockquote>
<div><dl class="docutils">
<dt>attr()        return a VGAttr instance representing an attribute</dt>
<dd>of the vgroup</dd>
<dt>findattr()    search the vgroup for a given attribute,</dt>
<dd>returning a VGAttr instance for that attribute</dd>
</dl>
</div></blockquote>
<p>ending access to a vgroup</p>
<blockquote>
<div>detach()      terminate access to the vgroup</div></blockquote>
<p>adding a member to a vgroup</p>
<blockquote>
<div><dl class="docutils">
<dt>add()         add to the vgroup the HDF object identified by its</dt>
<dd>tag and reference number</dd>
<dt>insert()      insert a vdata or a vgroup in the vgroup, given</dt>
<dd>the vdata or vgroup instance</dd>
</dl>
</div></blockquote>
<p>deleting a member from a vgroup</p>
<blockquote>
<div><dl class="docutils">
<dt>delete()      remove from the vgroup the HDF object identified</dt>
<dd>by the given tag and reference number</dd>
</dl>
</div></blockquote>
<p>querying vgroup</p>
<blockquote>
<div><p>attrinfo()    return info about all the vgroup attributes
inqtagref()   determine if the HDF object with the given</p>
<blockquote>
<div>tag and reference number belongs to the vgroup</div></blockquote>
<dl class="docutils">
<dt>isvg()        determine if the member with the given reference</dt>
<dd>number is a vgroup object</dd>
<dt>isvs()        determine if the member with the given reference</dt>
<dd>number is a vdata object</dd>
<dt>nrefs()       return the number of vgroup members with the</dt>
<dd>given tag</dd>
<dt>tagref()      get the tag and reference number of a vgroup</dt>
<dd>member, given the index number of that member</dd>
<dt>tagrefs()     get the tags and reference numbers of all the</dt>
<dd>vgroup members</dd>
</dl>
</div></blockquote>
</div></blockquote>
</div></blockquote>
<dl class="docutils">
<dt>VGAttr The VGAttr class provides methods to set and query vgroup</dt>
<dd><p class="first">attributes.</p>
<p>To create an instance of this class, call the attr() method
of a VG instance.</p>
<p>Remember that vgroup attributes can also be set and queried by
applying the standard python &#8220;dot notation&#8221; on a VG instance.</p>
<blockquote class="last">
<div><p>get attibute value(s)</p>
<blockquote>
<div>get()         obtain the attribute value(s)</div></blockquote>
<p>set attribute value(s)</p>
<blockquote>
<div><dl class="docutils">
<dt>set()         set the attribute to the given value(s) of the</dt>
<dd>given type, first creating the attribute if
necessary</dd>
</dl>
</div></blockquote>
<p>query attribute info</p>
<blockquote>
<div><dl class="docutils">
<dt>info()        retrieve attribute name, data type, order and</dt>
<dd>size</dd>
</dl>
</div></blockquote>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
</div>
<div class="section" id="attribute-access-low-and-high-level">
<h1>Attribute access: low and high level<a class="headerlink" href="#attribute-access-low-and-high-level" title="Permalink to this headline">¶</a></h1>
<p>The V API allows setting attributes on vgroups. Attributes can be of many
types (int, float, char) of different bit lengths (8, 16, 32, 64 bits),
and can be single or multi-valued. Values of a multi-valued attribute must
all be of the same type.</p>
<p>Attributes can be set and queried in two different ways. First, given a
VG instance (describing a vgroup object), the attr() method of that instance
is called to create a VGAttr instance representing the wanted attribute
(possibly non existent). The set() method of this VGAttr instance is then
called to define the attribute value, creating it if it does not already
exist. The get() method returns the current attribute value. Here is an
example.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyhdf.HDF</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyhdf.V</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">HDF</span><span class="p">(</span><span class="s">&#39;test.hdf&#39;</span><span class="p">,</span> <span class="n">HC</span><span class="o">.</span><span class="n">WRITE</span><span class="p">)</span> <span class="c"># Open file &#39;test.hdf&#39; in write mode</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">vgstart</span><span class="p">()</span>            <span class="c"># init vgroup interface</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vg</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">attach</span><span class="p">(</span><span class="s">&#39;vtest&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c"># attach vgroup &#39;vtest&#39; in write mode</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attr</span> <span class="o">=</span> <span class="n">vg</span><span class="o">.</span><span class="n">attr</span><span class="p">(</span><span class="s">&#39;version&#39;</span><span class="p">)</span>  <span class="c"># prepare to define the &#39;version&#39; attribute</span>
<span class="go">                               # on the vdata</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attr</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">HC</span><span class="o">.</span><span class="n">CHAR8</span><span class="p">,</span><span class="s">&#39;1.0&#39;</span><span class="p">)</span>   <span class="c"># set attribute &#39;version&#39; to string &#39;1.0&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">attr</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>           <span class="c"># get and print attribute value</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attr</span> <span class="o">=</span> <span class="n">vg</span> <span class="o">.</span><span class="n">attr</span><span class="p">(</span><span class="s">&#39;range&#39;</span><span class="p">)</span>   <span class="c"># prepare to define attribute &#39;range&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attr</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">HC</span><span class="o">.</span><span class="n">INT32</span><span class="p">,(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">))</span> <span class="c"># set attribute &#39;range&#39; to a pair of ints</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">attr</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>             <span class="c"># get and print attribute value</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">vg</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>                <span class="c"># &quot;close&quot; the vgroup</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>                    <span class="c"># terminate the vgroup interface</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>                  <span class="c"># close the HDF file</span>
</pre></div>
</div>
<p>The second way consists of setting/querying an attribute as if it were a
normal python class attribute, using the usual dot notation. Above example
then becomes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyhdf.HDF</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyhdf.V</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">HDF</span><span class="p">(</span><span class="s">&#39;test.hdf&#39;</span><span class="p">,</span> <span class="n">HC</span><span class="o">.</span><span class="n">WRITE</span><span class="p">)</span> <span class="c"># Open file &#39;test.hdf&#39; in write mode</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">vgstart</span><span class="p">()</span>            <span class="c"># init vgroup interface</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vg</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">attach</span><span class="p">(</span><span class="s">&#39;vtest&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c"># attach vdata &#39;vtest&#39; in write mode</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vg</span><span class="o">.</span><span class="n">version</span> <span class="o">=</span> <span class="s">&#39;1.0&#39;</span>         <span class="c"># create vdata attribute &#39;version&#39;,</span>
<span class="go">                               # setting it to string &#39;1.0&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">vg</span><span class="o">.</span><span class="n">version</span>           <span class="c"># print attribute value</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vg</span><span class="o">.</span><span class="n">range</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>       <span class="c"># create attribute &#39;range&#39;, setting</span>
<span class="go">                               # it to the pair of ints (-10, 15)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">vg</span><span class="o">.</span><span class="n">range</span>             <span class="c"># print attribute value</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vg</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>                <span class="c"># &quot;close&quot; the vdata</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>                    <span class="c"># terminate the vdata interface</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>                  <span class="c"># close the HDF file</span>
</pre></div>
</div>
<p>Note how the dot notation greatly simplifies and clarifies the code.
Some latitude is however lost by manipulating attributes in that way,
because the pyhdf package, not the programmer, is then responsible of
setting the attribute type. The attribute type is chosen to be one of:</p>
<blockquote>
<div>HC.CHAR8    if the attribute value is a string
HC.INT32    if all attribute values are integers
HC.FLOAT64  otherwise</div></blockquote>
<p>The first way of handling attribute values must be used if one wants to
define an attribute of any other type (for ex. 8 or 16 bit integers,
signed or unsigned). Also, only a VDAttr instance gives access to attribute
info, through its info() method.</p>
<p>However, accessing HDF attributes as if they were python attributes raises
an important issue. There must exist a way to assign generic attributes
to the python objects without requiring those attributes to be converted
to HDF attributes. pyhdf uses the following rule: an attribute whose name
starts with an underscore (&#8216;_&#8217;) is either a &#8220;predefined&#8221; HDF attribute
(see below) or a standard python attribute. Otherwise, the attribute
is handled as an HDF attribute. Also, HDF attributes are not stored inside
the object dictionnary: the python dir() function will not list them.</p>
<p>Attribute values can be updated, but it is illegal to try to change the
value type, or the attribute order (number of values). This is important
for attributes holding string values. An attribute initialized with an
&#8216;n&#8217; character string is simply a character attribute of order &#8216;n&#8217; (eg a
character array of length &#8216;n&#8217;). If &#8216;vg&#8217; is a vgroup and we initialize its
&#8216;a1&#8217; attribute as &#8216;vg.a1 = &#8220;abcdef&#8221;&#8217;, then a subsequent update attempt
like &#8216;vg.a1 = &#8220;12&#8221;&#8217; will fail, because we then try to change the order
of the attribute (from 6 to 2). It is mandatory to keep the length of string
attributes constant.</p>
</div>
<div class="section" id="predefined-attributes">
<h1>Predefined attributes<a class="headerlink" href="#predefined-attributes" title="Permalink to this headline">¶</a></h1>
<p>The VG class supports predefined attributes to get (and occasionnaly set)
attribute values easily using the usual python &#8220;dot notation&#8221;, without
having to call a class method. The names of predefined attributes all start
with an underscore (&#8216;_&#8217;).</p>
<p>In the following table, the RW column holds an X if the attribute
is read/write.</p>
<blockquote>
<div><p>VG predefined attributes</p>
<blockquote>
<div>_class      X   class name                  Vgetclass/Vsetclass
_name       X   vgroup name                 Vgetname/Vsetname
_nattrs         number of vgroup attributes Vnattrs
_nmembers       number of vgroup members    Vntagrefs
_refnum         vgroup reference number     VQueryref
_tag            vgroup tag                  VQuerytag
_version        vgroup version number       Vgetversion</div></blockquote>
</div></blockquote>
</div>
<div class="section" id="programming-models">
<h1>Programming models<a class="headerlink" href="#programming-models" title="Permalink to this headline">¶</a></h1>
</div>
<div class="section" id="creating-and-initializing-a-vgroup">
<h1>Creating and initializing a vgroup<a class="headerlink" href="#creating-and-initializing-a-vgroup" title="Permalink to this headline">¶</a></h1>
<p>The following program shows how to create and initialize a vgroup inside
an HDF file. It can serve as a model for any program wanting to create
a vgroup.</p>
<blockquote>
<div><p>from pyhdf.HDF import *
from pyhdf.V   import *
from pyhdf.VS  import *
from pyhdf.SD  import *</p>
<p>def vdatacreate(vs, name):</p>
<blockquote>
<div><p># Create vdata and define its structure
vd = vs.create(name,</p>
<blockquote>
<div><dl class="docutils">
<dt>((&#8216;partid&#8217;,HC.CHAR8, 5),       # 5 char string</dt>
<dd>(&#8216;description&#8217;,HC.CHAR8, 10), # 10 char string field
(&#8216;qty&#8217;,HC.INT16, 1),          # 1 16 bit int field
(&#8216;wght&#8217;,HC.FLOAT32, 1),       # 1 32 bit float
(&#8216;price&#8217;,HC.FLOAT32,1)        # 1 32 bit float</dd>
</dl>
<p>))</p>
</div></blockquote>
<p># Store records
vd.write(((&#8216;Q1234&#8217;, &#8216;bolt&#8217;,12, 0.01, 0.05),   # record 1</p>
<blockquote>
<div>(&#8216;B5432&#8217;, &#8216;brush&#8217;, 10, 0.4, 4.25),  # record 2
(&#8216;S7613&#8217;, &#8216;scissor&#8217;, 2, 0.2, 3.75)  # record 3
))</div></blockquote>
<p># &#8220;close&#8221; vdata
vd.detach()</p>
</div></blockquote>
<p>def sdscreate(sd, name):</p>
<blockquote>
<div># Create a simple 3x3 float array.
sds = sd.create(name, SDC.FLOAT32, (3,3))
# Initialize array
sds[:] = ((0,1,2),(3,4,5),(6,7,8))
# &#8220;close&#8221; dataset.
sds.endaccess()</div></blockquote>
<p># Create HDF file
filename = &#8216;inventory.hdf&#8217;
hdf = HDF(filename, HC.WRITE|HC.CREATE)</p>
<p># Initialize the SD, V and VS interfaces on the file.
sd = SD(filename, SDC.WRITE)  # SD interface
vs = hdf.vstart()             # vdata interface
v  = hdf.vgstart()            # vgroup interface</p>
<p># Create vdata named &#8216;INVENTORY&#8217;.
vdatacreate(vs, &#8216;INVENTORY&#8217;)
# Create dataset named &#8220;ARR_3x3&#8221;
sdscreate(sd, &#8216;ARR_3x3&#8217;)</p>
<p># Attach the vdata and the dataset.
vd = vs.attach(&#8216;INVENTORY&#8217;)
sds = sd.select(&#8216;ARR_3x3&#8217;)</p>
<p># Create vgroup named &#8216;TOTAL&#8217;.
vg = v.create(&#8216;TOTAL&#8217;)</p>
<p># Add vdata to the vgroup
vg.insert(vd)
# We could also have written this:
# vgroup.add(vd._tag, vd._refnum)
# or this:
# vgroup.add(HC.DFTAG_VH, vd._refnum)</p>
<p># Add dataset to the vgroup
vg.add(HC.DFTAG_NDG, sds.ref())</p>
<p># Close vgroup, vdata and dataset.
vg.detach()       # vgroup
vd.detach()       # vdata
sds.endaccess()   # dataset</p>
<p># Terminate V, VS and SD interfaces.
v.end()           # V interface
vs.end()          # VS interface
sd.end()          # SD interface</p>
<p># Close HDF file.
hdf.close()</p>
</div></blockquote>
<p>The program starts by defining two functions vdatacreate() and sdscreate(),
which will serve to create the vdata and dataset objects we need. Those
functions are not essential to the example. They simply help to make the
example self-contained. Refer to the VS and SD module documentation for
additional explanations about how these functions work.</p>
<p>After opening the HDF file in write mode, the SD, V and VS interfaces are
initialized on the file. Next vdatacreate() is called to create a new vdata
named &#8216;INVENTORY&#8217; on the VS instance, and sdscreate() to create a new
dataset named &#8216;ARR_3x3&#8217; on the SD instance. This is done so that we have a
vdata and a dataset to play with.</p>
<p>The vdata and the dataset are then attached (&#8220;opened&#8221;). The create()
method of the V instance is then called to create a new vgroup named
&#8216;TOTAL&#8217;. The vgroup is then populated by calling its insert() method to add
the vdata &#8216;INVENTORY&#8217;, and its add() method to add the &#8216;ARR_3x3&#8217; dataset.
Note that insert() is just a commodity method that simplifies adding a
vdata or a vgroup to a vgroup, avoiding the need to pass an object tag and
reference number. There is no such commodity method for adding a dataset
to a vgroup. The dataset must be added by specifying its tag and reference
number. Note that the tags to be used are defined inside the HDF module as
constants of the HC class: DFTAG_NDG for a dataset, DFTAG_VG for a vgroup,
DFTAG_VH for a vdata.</p>
<p>The program ends by detaching (&#8220;closing&#8221;) the HDF objects created above,
terminating the three interfaces initialized, and closing the HDF file.</p>
</div>
<div class="section" id="reading-a-vgroup">
<h1>Reading a vgroup<a class="headerlink" href="#reading-a-vgroup" title="Permalink to this headline">¶</a></h1>
<p>The following program shows the contents of the vgroups contained inside
any HDF file.</p>
<blockquote>
<div><p>from pyhdf.HDF import *
from pyhdf.V   import *
from pyhdf.VS  import *
from pyhdf.SD  import *</p>
<p>import sys</p>
<p>def describevg(refnum):</p>
<blockquote>
<div><p># Describe the vgroup with the given refnum.</p>
<p># Open vgroup in read mode.
vg = v.attach(refnum)
print &#8220;&#8212;&#8212;&#8212;&#8212;&#8212;-&#8221;
print &#8220;name:&#8221;, vg._name, &#8220;class:&#8221;,vg._class, &#8220;tag,ref:&#8221;,
print vg._tag, vg._refnum</p>
<p># Show the number of members of each main object type.
print &#8220;members: &#8221;, vg._nmembers,
print &#8220;datasets:&#8221;, vg.nrefs(HC.DFTAG_NDG),
print &#8220;vdatas:  &#8221;, vg.nrefs(HC.DFTAG_VH),
print &#8220;vgroups: &#8221;, vg.nrefs(HC.DFTAG_VG)</p>
<p># Read the contents of the vgroup.
members = vg.tagrefs()</p>
<p># Display info about each member.
index = -1
for tag, ref in members:</p>
<blockquote>
<div><p>index += 1
print &#8220;member index&#8221;, index
# Vdata tag
if tag == HC.DFTAG_VH:</p>
<blockquote>
<div>vd = vs.attach(ref)
nrecs, intmode, fields, size, name = vd.inquire()
print &#8221;  vdata:&#8221;,name, &#8220;tag,ref:&#8221;,tag, ref
print &#8221;    fields:&#8221;,fields
print &#8221;    nrecs:&#8221;,nrecs
vd.detach()</div></blockquote>
<p># SDS tag
elif tag == HC.DFTAG_NDG:</p>
<blockquote>
<div>sds = sd.select(sd.reftoindex(ref))
name, rank, dims, type, nattrs = sds.info()
print &#8221;  dataset:&#8221;,name, &#8220;tag,ref:&#8221;, tag, ref
print &#8221;    dims:&#8221;,dims
print &#8221;    type:&#8221;,type
sds.endaccess()</div></blockquote>
<p># VS tag
elif tag == HC.DFTAG_VG:</p>
<blockquote>
<div>vg0 = v.attach(ref)
print &#8221;  vgroup:&#8221;, vg0._name, &#8220;tag,ref:&#8221;, tag, ref
vg0.detach()</div></blockquote>
<p># Unhandled tag
else:</p>
<blockquote>
<div>print &#8220;unhandled tag,ref&#8221;,tag,ref</div></blockquote>
</div></blockquote>
<p># Close vgroup
vg.detach()</p>
</div></blockquote>
<p># Open HDF file in readonly mode.
filename = sys.argv[1]
hdf = HDF(filename)</p>
<p># Initialize the SD, V and VS interfaces on the file.
sd = SD(filename)
vs = hdf.vstart()
v  = hdf.vgstart()</p>
<p># Scan all vgroups in the file.
ref = -1
while 1:</p>
<blockquote>
<div><dl class="docutils">
<dt>try:</dt>
<dd>ref = v.getid(ref)</dd>
<dt>except HDF4Error,msg:    # no more vgroup</dt>
<dd>break</dd>
</dl>
<p>describevg(ref)</p>
</div></blockquote>
<p># Terminate V, VS and SD interfaces.
v.end()
vs.end()
sd.end()</p>
<p># Close HDF file.
hdf.close()</p>
</div></blockquote>
<p>The program starts by defining function describevg(), which is passed the
reference number of the vgroup to display. The function assumes that the
SD, VS and V interfaces have been previously initialized.</p>
<p>The function starts by attaching (&#8220;opening&#8221;) the vgroup, and displaying
its name, class, tag and reference number. The number of members of the
three most important object types is then displayed, by calling the nrefs()
method with the predefined tags found inside the HDF.HC class.</p>
<p>The tagrefs() method is then called to get a list of all the vgroup members,
each member being identified by its tag and reference number. A &#8216;for&#8217;
statement is entered to loop over each element of this list. The tag is
tested against the known values defined in the HDF.HC class: the outcome of
this test indicates how to process the member object.</p>
<p>A DFTAG_VH tag indicates we deal with a vdata. The vdata is attached, its
inquire() method called to display info about it, and the vdata is detached.
In the case of a DFTAG_NFG, we are facing a dataset. The dataset is
selected, info is obtained by calling the dataset info() method, and the
dataset is released. A DFTAG_VG indicates that the member is a vgroup. We
attach it, print its name, tag and reference number, then detach the
member vgroup. A warning is finally displayed if we hit upon a member of
an unknown type.</p>
<p>The function releases the vgroup just displayed and returns.</p>
<p>The main program starts by opening in readonly mode the HDF file passed
as argument on the command line. The SD, VS and V interfaces are
initialized, and the corresponding class instances are stored inside &#8216;sd&#8217;,
&#8216;vs&#8217; and &#8216;v&#8217; global variables, respectively, for the use of the
describevg() function.</p>
<p>A while loop is then entered to access each vgroup in the file. A reference
number of -1 is passed on the first call to getid() to obtain the reference
number of the first vgroup. getid() returns a new reference number on each
subsequent call, and raises an exception when the last vgroup has been
retrieved. This exception is caught to break out of the loop, otherwise
describevg() is called to display the vgroup we have on hand.</p>
<p>Once the loop is over, the interfaces initialized before are terminated,
and the HDF file is closed.</p>
<p>You will notice that this program will display vgroups other than those
you have explicitly created. Those supplementary vgroups are created
by the HDF library for its own internal needs.</p>
<dl class="class">
<dt id="pyhdf.V.V">
<em class="property">class </em><tt class="descclassname">pyhdf.V.</tt><tt class="descname">V</tt><big>(</big><em>hinst</em><big>)</big><a class="headerlink" href="#pyhdf.V.V" title="Permalink to this definition">¶</a></dt>
<dd><p>The V class implements the V (Vgroup) interface applied to an
HDF file.
To instantiate a V class, call the vgstart() method of an
HDF instance.</p>
<dl class="method">
<dt id="pyhdf.V.V.attach">
<tt class="descname">attach</tt><big>(</big><em>num_name</em>, <em>write=0</em><big>)</big><a class="headerlink" href="#pyhdf.V.V.attach" title="Permalink to this definition">¶</a></dt>
<dd><p>Open an existing vgroup given its name or its reference
number, or create a new vgroup, returning a VG instance for
that vgroup.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>num_name      reference number or name of the vgroup to open,</dt>
<dd>or -1 to create a new vgroup; vcreate() can also
be called to create and name a new vgroup</dd>
<dt>write         set to non-zero to open the vgroup in write mode</dt>
<dd>and to 0 to open it in readonly mode (default)</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>VG instance for the vgroup</dd>
</dl>
<p>An exception is raised if an attempt is made to open
a non-existent vgroup.</p>
<p>C library equivalent : Vattach</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.V.V.create">
<tt class="descname">create</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#pyhdf.V.V.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new vgroup, and assign it a name.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>name   name to assign to the new vgroup</dd>
<dt>Returns:</dt>
<dd>VG instance for the new vgroup</dd>
</dl>
<p>A create(name) call is equivalent to an attach(-1, 1) call,
followed by a call to the setname(name) method of the instance.</p>
<p>C library equivalent : no equivalent</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.V.V.delete">
<tt class="descname">delete</tt><big>(</big><em>num_name</em><big>)</big><a class="headerlink" href="#pyhdf.V.V.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete from the HDF file the vgroup identified by its
reference number or its name.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>num_name    either the reference number or the name of</dt>
<dd>the vgroup to delete</dd>
</dl>
</dd>
<dt>Return</dt>
<dd>None</dd>
</dl>
<p>C library equivalent : Vdelete</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.V.V.end">
<tt class="descname">end</tt><big>(</big><big>)</big><a class="headerlink" href="#pyhdf.V.V.end" title="Permalink to this definition">¶</a></dt>
<dd><p>Close the V interface.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>No argument</dd>
<dt>Returns:</dt>
<dd>None</dd>
</dl>
<p>C library equivalent : Vend</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.V.V.find">
<tt class="descname">find</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#pyhdf.V.V.find" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a vgroup given its name, returning its reference
number if found.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>name     name of the vgroup to find</dd>
<dt>Returns:</dt>
<dd>vgroup reference number</dd>
</dl>
<p>An exception is raised if the vgroup is not found.</p>
<p>C library equivalent: Vfind</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.V.V.findclass">
<tt class="descname">findclass</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#pyhdf.V.V.findclass" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a vgroup given its class name, returning its reference
number if found.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>name     class name of the vgroup to find</dd>
<dt>Returns:</dt>
<dd>vgroup reference number</dd>
</dl>
<p>An exception is raised if the vgroup is not found.</p>
<p>C library equivalent: Vfind</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.V.V.getid">
<tt class="descname">getid</tt><big>(</big><em>ref</em><big>)</big><a class="headerlink" href="#pyhdf.V.V.getid" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain the reference number of the vgroup following the
vgroup with the given reference number .</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>ref    reference number of the vgroup after which to search;</dt>
<dd>set to -1 to start the search at the start of
the HDF file</dd>
</dl>
</dd>
<dt>Return:</dt>
<dd>reference number of the vgroup past the one identified by &#8216;ref&#8217;</dd>
</dl>
<p>An exception is raised if the end of the vgroup is reached.</p>
<p>C library equivalent : Vgetid</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyhdf.V.VG">
<em class="property">class </em><tt class="descclassname">pyhdf.V.</tt><tt class="descname">VG</tt><big>(</big><em>vinst</em>, <em>id</em><big>)</big><a class="headerlink" href="#pyhdf.V.VG" title="Permalink to this definition">¶</a></dt>
<dd><p>The VG class encapsulates the functionnality of a vgroup.
To instantiate a VG class, call the attach() or create() methods
of a V class instance.</p>
<dl class="method">
<dt id="pyhdf.V.VG.add">
<tt class="descname">add</tt><big>(</big><em>tag</em>, <em>ref</em><big>)</big><a class="headerlink" href="#pyhdf.V.VG.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add to the vgroup an object identified by its tag and
reference number.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>tag       tag of the object to add
ref       reference number of the object to add</dd>
<dt>Return:</dt>
<dd>total number of objects in the vgroup after the addition</dd>
</dl>
<p>C library equivalent : Vaddtagref</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.V.VG.attr">
<tt class="descname">attr</tt><big>(</big><em>name_index</em><big>)</big><a class="headerlink" href="#pyhdf.V.VG.attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a VGAttr instance representing a vgroup attribute.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>name_index  attribute name or attribute index number; if a</dt>
<dd>name is given the attribute may not exist; in that
case, it will be created when the VGAttr
instance set() method is called</dd>
</dl>
</dd>
<dt>Return:</dt>
<dd>VGAttr instance for the attribute. Call the methods of this
class to query, read or set the attribute.</dd>
</dl>
<p>C library equivalent : no equivalent</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.V.VG.attrinfo">
<tt class="descname">attrinfo</tt><big>(</big><big>)</big><a class="headerlink" href="#pyhdf.V.VG.attrinfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Return info about all the vgroup attributes.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>no argument</dd>
<dt>Returns:</dt>
<dd><p class="first">dictionnary describing each vgroup attribute; for each attribute,
a (name,data) pair is added to the dictionary, where &#8216;data&#8217; is
a tuple holding:</p>
<blockquote class="last">
<div>-attribute data type (one of HC.xxx constants)
-attribute order
-attribute value
-attribute size in bytes</div></blockquote>
</dd>
</dl>
<p>C library equivalent : no equivalent</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.V.VG.delete">
<tt class="descname">delete</tt><big>(</big><em>tag</em>, <em>ref</em><big>)</big><a class="headerlink" href="#pyhdf.V.VG.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete from the vgroup the member identified by its tag
and reference number.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>tag    tag of the member to delete
ref    reference number of the member to delete</dd>
<dt>Return:</dt>
<dd>None</dd>
</dl>
<p>Only the link of the member with the vgroup is deleted.
The member object is not deleted.</p>
<p>C library equivalent : Vdeletatagref</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.V.VG.detach">
<tt class="descname">detach</tt><big>(</big><big>)</big><a class="headerlink" href="#pyhdf.V.VG.detach" title="Permalink to this definition">¶</a></dt>
<dd><p>Terminate access to the vgroup.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>no argument</dd>
<dt>Returns:</dt>
<dd>None</dd>
</dl>
<p>C library equivalent : Vdetach</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.V.VG.findattr">
<tt class="descname">findattr</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#pyhdf.V.VG.findattr" title="Permalink to this definition">¶</a></dt>
<dd><p>Search the vgroup for a given attribute.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>name    attribute name</dd>
<dt>Returns:</dt>
<dd><blockquote class="first">
<div>if found, VGAttr instance describing the attribute
None otherwise</div></blockquote>
<p class="last">C library equivalent : Vfindattr</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyhdf.V.VG.inqtagref">
<tt class="descname">inqtagref</tt><big>(</big><em>tag</em>, <em>ref</em><big>)</big><a class="headerlink" href="#pyhdf.V.VG.inqtagref" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines if an object identified by its tag and reference
number belongs to the vgroup.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>tag      tag of the object to check
ref      reference number of the object to check</dd>
<dt>Return:</dt>
<dd>False (0) if the object does not belong to the vgroup,
True  (1) otherwise</dd>
</dl>
<p>C library equivalent : Vinqtagref</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.V.VG.insert">
<tt class="descname">insert</tt><big>(</big><em>inst</em><big>)</big><a class="headerlink" href="#pyhdf.V.VG.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert a vdata or a vgroup in the vgroup.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>inst  vdata or vgroup instance to add</dd>
<dt>Return:</dt>
<dd>index of the inserted vdata or vgroup (0 based)</dd>
</dl>
<p>C library equivalent : Vinsert</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.V.VG.isvg">
<tt class="descname">isvg</tt><big>(</big><em>ref</em><big>)</big><a class="headerlink" href="#pyhdf.V.VG.isvg" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines if the member of a vgoup is a vgroup.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>ref      reference number of the member to check</dd>
<dt>Return:</dt>
<dd>False (0) if the member is not a vgroup
True  (1) otherwise</dd>
</dl>
<p>C library equivalent : Visvg</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.V.VG.isvs">
<tt class="descname">isvs</tt><big>(</big><em>ref</em><big>)</big><a class="headerlink" href="#pyhdf.V.VG.isvs" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines if the member of a vgoup is a vdata.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>ref      reference number of the member to check</dd>
<dt>Return:</dt>
<dd>False (0) if the member is not a vdata,
True  (1) otherwise</dd>
</dl>
<p>C library equivalent : Visvs</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.V.VG.nrefs">
<tt class="descname">nrefs</tt><big>(</big><em>tag</em><big>)</big><a class="headerlink" href="#pyhdf.V.VG.nrefs" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the number of tags of a given type in a vgroup.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>tag    tag type to look for in the vgroup</dd>
<dt>Return:</dt>
<dd>number of members identified by this tag type</dd>
</dl>
<p>C library equivalent : Vnrefs</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.V.VG.tagref">
<tt class="descname">tagref</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#pyhdf.V.VG.tagref" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the tag and reference number of a vgroup member,
given the index number of that member.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>index   member index (0 based)</dd>
<dt>Return:</dt>
<dd><dl class="first last docutils">
<dt>2-element tuple:</dt>
<dd><ul class="first last simple">
<li>member tag</li>
<li>member reference number</li>
</ul>
</dd>
</dl>
</dd>
</dl>
<p>C library equivalent : Vgettagref</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.V.VG.tagrefs">
<tt class="descname">tagrefs</tt><big>(</big><big>)</big><a class="headerlink" href="#pyhdf.V.VG.tagrefs" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the tags and reference numbers of all the vgroup
members.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>no argument</dd>
<dt>Return:</dt>
<dd>list of (tag,ref) tuples, one for each vgroup member</dd>
</dl>
<p>C library equivalent : Vgettagrefs</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyhdf.V.VGAttr">
<em class="property">class </em><tt class="descclassname">pyhdf.V.</tt><tt class="descname">VGAttr</tt><big>(</big><em>obj</em>, <em>name_or_index</em><big>)</big><a class="headerlink" href="#pyhdf.V.VGAttr" title="Permalink to this definition">¶</a></dt>
<dd><p>The VGAttr class encapsulates methods used to set and query
attributes defined on a vgroup. To create an instance of this class,
call the attr() method of a VG class.</p>
<dl class="method">
<dt id="pyhdf.V.VGAttr.get">
<tt class="descname">get</tt><big>(</big><big>)</big><a class="headerlink" href="#pyhdf.V.VGAttr.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the attribute value.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>no argument</dd>
<dt>Returns: </dt>
<dd>attribute value(s); a list is returned if the attribute
is made up of more than one value, except in the case of a 
string-valued attribute (data type HC.CHAR8) where the 
values are returned as a string</dd>
</dl>
<p>Note that a vgroup attribute can also be queried like a standard
python class attribute by applying the usual &#8220;dot notation&#8221; to a
VG instance.</p>
<p>C library equivalent : Vgetattr</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.V.VGAttr.info">
<tt class="descname">info</tt><big>(</big><big>)</big><a class="headerlink" href="#pyhdf.V.VGAttr.info" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve info about the attribute.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>no argument</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>4-element tuple with the following components:</dt>
<dd>-attribute name
-attribute data type (one of HC.xxx constants)
-attribute order (number of values)
-attribute size in bytes</dd>
</dl>
</dd>
</dl>
<p>C library equivalent : Vattrinfo</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.V.VGAttr.set">
<tt class="descname">set</tt><big>(</big><em>data_type</em>, <em>values</em><big>)</big><a class="headerlink" href="#pyhdf.V.VGAttr.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the attribute value.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">data_type    : attribute data type (see constants HC.xxx)
values       : attribute value(s); specify a list to create</p>
<blockquote class="last">
<div><p>a multi-valued attribute; a string valued
attribute can be created by setting &#8216;data_type&#8217;
to HC.CHAR8 and &#8216;values&#8217; to the corresponding
string</p>
<p>If the attribute already exists, it will be
updated. However, it is illegal to try to change
its data type or its order (number of values).</p>
</div></blockquote>
</dd>
<dt>Returns: </dt>
<dd>None</dd>
</dl>
<p>Note that a vgroup attribute can also be set like a standard
python class attribute by applying the usual &#8220;dot notation&#8221; to a
VG instance.</p>
<p>C library equivalent : Vsetattr</p>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Table of contents</a></li>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#accessing-the-v-module">Accessing the V module</a></li>
<li><a class="reference internal" href="#package-components">Package components</a></li>
<li><a class="reference internal" href="#prerequisites">Prerequisites</a></li>
<li><a class="reference internal" href="#summary-of-differences-between-the-pyhdf-and-c-v-api">Summary of differences between the pyhdf and C V API</a></li>
<li><a class="reference internal" href="#error-handling">Error handling</a></li>
<li><a class="reference internal" href="#v-needs-support-from-the-hdf-module">V needs support from the HDF module</a></li>
<li><a class="reference internal" href="#classes-summary">Classes summary</a></li>
<li><a class="reference internal" href="#attribute-access-low-and-high-level">Attribute access: low and high level</a></li>
<li><a class="reference internal" href="#predefined-attributes">Predefined attributes</a></li>
<li><a class="reference internal" href="#programming-models">Programming models</a></li>
<li><a class="reference internal" href="#creating-and-initializing-a-vgroup">Creating and initializing a vgroup</a></li>
<li><a class="reference internal" href="#reading-a-vgroup">Reading a vgroup</a></li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="VS.html"
                        title="previous chapter">Table of contents</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/modules/V.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="VS.html" title="Table of contents"
             >previous</a> |</li>
        <li><a href="../index.html">pyhdf 0.9 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, pyhdf authors.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>