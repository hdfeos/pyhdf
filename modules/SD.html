<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Table of contents &mdash; pyhdf 0.9 documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.9',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="pyhdf 0.9 documentation" href="../index.html" />
    <link rel="next" title="Table of contents" href="VS.html" />
    <link rel="prev" title="Introduction" href="HDF.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="VS.html" title="Table of contents"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="HDF.html" title="Introduction"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">pyhdf 0.9 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <span class="target" id="module-pyhdf.SD"></span><p>A module of the pyhdf package implementing the SD (scientific
dataset) API of the NCSA HDF4 library.
(see: hdf.ncsa.uiuc.edu)</p>
<dl class="docutils">
<dt>Author: Andre Gosselin</dt>
<dd>Maurice Lamontagne Institute
<a class="reference external" href="mailto:Andre&#46;Gosselin&#37;&#52;&#48;dfo-mpo&#46;gc&#46;ca">Andre<span>&#46;</span>Gosselin<span>&#64;</span>dfo-mpo<span>&#46;</span>gc<span>&#46;</span>ca</a></dd>
<dt>Maintainer:     Enthough, Inc.</dt>
<dd>Austin, TX
<a class="reference external" href="mailto:enthought-dev&#37;&#52;&#48;mail&#46;enthought&#46;com">enthought-dev<span>&#64;</span>mail<span>&#46;</span>enthought<span>&#46;</span>com</a></dd>
</dl>
<p>Version: 0.8-1
Date:    August 4 2008</p>
<div class="section" id="table-of-contents">
<h1>Table of contents<a class="headerlink" href="#table-of-contents" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div>Introduction
SD module key features
Accessing the SD module
Package components
Prerequisites
Documentation
Summary of differences between the pyhdf and C SD API
Error handling
Attribute access: low and high level
Variable access: low and high level
Reading/setting multivalued HDF attributes and variables
netCDF files
Classes summary
Data types
Programming models
Examples
Module documentation</div></blockquote>
</div>
<div class="section" id="introduction">
<h1>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h1>
<p>SD is one of the modules composing pyhdf, a python package implementing
the NCSA HDF library and letting one manage HDF files from within a python
program. Two versions of the HDF library currently exist, version 4 and
version 5. pyhdf only implements version 4 of the library. Many
different APIs are to be found inside the HDF4 specification.
Currently, pyhdf implements just a few of those: the SD, VS and V APIs.
Other APIs should be added in the future (GR, AN, etc).</p>
<p>The SD module implements the SD API of the HDF4 library, supporting what
are known as &#8220;scientific datasets&#8221;. The HDF SD API has many similarities
with the netCDF API, another popular API for dealing with scientific
datasets. netCDF files can be in fact read and modified using the SD
module (but cannot be created from scratch).</p>
</div>
<div class="section" id="sd-module-key-features">
<h1>SD module key features<a class="headerlink" href="#sd-module-key-features" title="Permalink to this headline">¶</a></h1>
<p>SD key features are as follows.</p>
<blockquote>
<div><dl class="docutils">
<dt>-Almost every routine of the original SD API has been implemented inside</dt>
<dd><dl class="first last docutils">
<dt>pyhdf. Only a few have been ignored, most of them being of a rare use:</dt>
<dd><ul class="first last simple">
<li>SDsetnbitdataset()</li>
<li>All chunking/tiling routines : SDgetchunkinfo(), SDreadchunk(),
SDsetchunk(), SDsetchunkcache(), SDwritechunk()</li>
<li>SDsetblocksize()</li>
<li>SDisdimval_bwcomp(), SDsetdimval_comp()</li>
</ul>
</dd>
</dl>
</dd>
<dt>-It is quite straightforward to go from a C version to a python version</dt>
<dd>of a program accessing the SD API, and to learn SD usage by refering to
the C API documentation.</dd>
<dt>-A few high-level python methods have been developped to ease</dt>
<dd><p class="first">programmers task. Of greatest interest are those allowing access
to SD datasets through familiar python idioms.</p>
<blockquote class="last">
<div><dl class="docutils">
<dt>-Attributes can be read/written like ordinary python class</dt>
<dd>attributes.</dd>
<dt>-Datasets can be read/written like ordinary python lists using</dt>
<dd><p class="first">multidimensional indices and so-called &#8220;extended slice syntax&#8221;, with
strides allowed.</p>
<p class="last">See &#8220;High level attribute access&#8221; and &#8220;High level variable access&#8221;
sections for details.</p>
</dd>
<dt>-SD offers methods to retrieve a dictionnary of the attributes,</dt>
<dd>dimensions and variables defined on a dataset, and of the attributes
set on a variable and a dimension. Querying a dataset is thus geatly
simplified.</dd>
</dl>
</div></blockquote>
</dd>
<dt>-SD datasets are read/written through &#8220;numpy&#8221;, a sophisticated</dt>
<dd>python package for efficiently handling multi-dimensional arrays of
numbers. numpy can nicely extend the SD functionnality, eg.
adding/subtracting arrays with the &#8216;+/-&#8216; operators.</dd>
</dl>
</div></blockquote>
</div>
<div class="section" id="accessing-the-sd-module">
<h1>Accessing the SD module<a class="headerlink" href="#accessing-the-sd-module" title="Permalink to this headline">¶</a></h1>
<p>To access the SD API a python program can say one of:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyhdf.SD</span>        <span class="c"># must prefix names with &quot;pyhdf.SD.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyhdf</span> <span class="kn">import</span> <span class="n">SD</span>   <span class="c"># must prefix names with &quot;SD.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyhdf.SD</span> <span class="kn">import</span> <span class="o">*</span> <span class="c"># names need no prefix</span>
</pre></div>
</div>
<p>This document assumes the last import style is used.</p>
<p>numpy will also need to be imported:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
</div>
<div class="section" id="package-components">
<h1>Package components<a class="headerlink" href="#package-components" title="Permalink to this headline">¶</a></h1>
<p>pyhdf is a proper Python package, eg a collection of modules stored under
a directory whose name is that of the package and which stores an
__init__.py file. Following the normal installation procedure, this
directory will be &lt;python-lib&gt;/site-packages/pyhdf&#8217;, where &lt;python-lib&gt;
stands for the python installation directory.</p>
<p>For each HDF API exists a corresponding set of modules.</p>
<p>The following modules are related to the SD API.</p>
<blockquote>
<div><dl class="docutils">
<dt>_hdfext   C extension module responsible for wrapping the HDF</dt>
<dd>C-library for all python modules</dd>
<dt>hdfext    python module implementing some utility functions</dt>
<dd>complementing the _hdfext extension module</dd>
</dl>
<p>error     defines the HDF4Error exception
SD        python module wrapping the SD API routines inside</p>
<blockquote>
<div>an OOP framework</div></blockquote>
</div></blockquote>
<p>_hdfext and hdfext were generated using the SWIG preprocessor.
SWIG is however <em>not</em> needed to run the package. Those two modules
are meant to do their work in the background, and should never be called
directly. Only &#8216;pyhdf.SD&#8217; should be imported by the user program.</p>
</div>
<div class="section" id="prerequisites">
<h1>Prerequisites<a class="headerlink" href="#prerequisites" title="Permalink to this headline">¶</a></h1>
<p>The following software must be installed in order for pyhdf release 0.8 to
work.</p>
<blockquote>
<div><dl class="docutils">
<dt>HDF (v4) library, release 4.2r1</dt>
<dd><p class="first">pyhdf does <em>not</em> include the HDF4 library, which must
be installed separately.</p>
<p class="last">HDF is available at:
&#8220;<a class="reference external" href="http://hdf.ncsa.uiuc.edu/obtain.html">http://hdf.ncsa.uiuc.edu/obtain.html</a>&#8221;.</p>
</dd>
</dl>
<p>HDF4.2r1 in turn relies on the following packages :</p>
<blockquote>
<div><p>libjpeg (jpeg library) release 6b
libz    (zlib library) release 1.1.4 or above
libsz   (SZIP library) release 2.0; this package is optional</p>
<blockquote>
<div>if pyhdf is installed with NOSZIP macro set</div></blockquote>
</div></blockquote>
</div></blockquote>
<p>The SD module also needs:</p>
<blockquote>
<div><dl class="docutils">
<dt>numpy python package</dt>
<dd><p class="first">SD variables are read/written using the array data type provided
by the python NumPy package. Note that since version 0.8 of
pyhdf, version 1.0.5 or above of NumPy is needed.</p>
<p class="last">numpy is available at:
&#8220;<a class="reference external" href="http://www.numpy.org">http://www.numpy.org</a>&#8221;.</p>
</dd>
</dl>
</div></blockquote>
</div>
<div class="section" id="documentation">
<h1>Documentation<a class="headerlink" href="#documentation" title="Permalink to this headline">¶</a></h1>
<p>pyhdf has been written so as to stick as closely as possible to 
the naming conventions and calling sequences documented inside the
&#8220;HDF User s Guide&#8221; manual. Even if pyhdf gives an OOP twist
to the C API, the manual can be easily used as a documentary source
for pyhdf, once the class to which a function belongs has been
identified, and of course once requirements imposed by the Python
langage have been taken into account. Consequently, this documentation
will not attempt to provide an exhaustive coverage of the HDF SD
API. For this, the user is referred to the above manual.
The documentation of each pyhdf method will indicate the name
of the equivalent routine inside the C API.</p>
<p>This document (in both its text and html versions) has been completely
produced using &#8220;pydoc&#8221;, the Python documentation generator (which
made its debut in the 2.1 Python release). pydoc can also be used
as an on-line help tool. For example, to know everything about
the SD.SDS class, say:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pydoc</span> <span class="kn">import</span> <span class="n">help</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyhdf.SD</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">help</span><span class="p">(</span><span class="n">SDS</span><span class="p">)</span>
</pre></div>
</div>
<p>To be more specific and get help only for the get() method of the
SDS class:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">help</span><span class="p">(</span><span class="n">SDS</span><span class="o">.</span><span class="n">get</span><span class="p">)</span>   <span class="c"># or...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">help</span><span class="p">(</span><span class="n">vinst</span><span class="o">.</span><span class="n">get</span><span class="p">)</span> <span class="c"># if vinst is an SDS instance</span>
</pre></div>
</div>
<p>pydoc can also be called from the command line, as in:</p>
<blockquote>
<div>% pydoc pyhdf.SD.SDS        # doc for the whole SDS class
% pydoc pyhdf.SD.SDS.get    # doc for the SDS.get method</div></blockquote>
</div>
<div class="section" id="summary-of-differences-between-the-pyhdf-and-c-sd-api">
<h1>Summary of differences between the pyhdf and C SD API<a class="headerlink" href="#summary-of-differences-between-the-pyhdf-and-c-sd-api" title="Permalink to this headline">¶</a></h1>
<p>Most of the differences between the pyhdf and C SD API can
be summarized as follows.</p>
<blockquote>
<div><dl class="docutils">
<dt>-In the C API, every function returns an integer status code, and values</dt>
<dd>computed by the function are returned through one or more pointers
passed as arguments.</dd>
<dt>-In pyhdf, error statuses are returned through the Python exception</dt>
<dd>mechanism, and values are returned as the method result. When the
C API specifies that multiple values are returned, pyhdf returns a 
tuple of values, which are ordered similarly to the pointers in the
C function argument list.</dd>
</dl>
</div></blockquote>
</div>
<div class="section" id="error-handling">
<h1>Error handling<a class="headerlink" href="#error-handling" title="Permalink to this headline">¶</a></h1>
<p>All errors that the C SD API reports with a SUCCESS/FAIL error code
are reported by pyhdf using the Python exception mechanism.
When the C library reports a FAIL status, pyhdf raises an HDF4Error
exception (a subclass of Exception) with a descriptive message. 
Unfortunately, the C library is rarely informative about the cause of 
the error. pyhdf does its best to try to document the error, but most 
of the time cannot do more than saying &#8220;execution error&#8221;.</p>
</div>
<div class="section" id="attribute-access-low-and-high-level">
<h1>Attribute access: low and high level<a class="headerlink" href="#attribute-access-low-and-high-level" title="Permalink to this headline">¶</a></h1>
<p>In the SD API, attributes can be of many types (integer, float, string,
etc) and can be single or multi-valued. Attributes can be set either at
the dataset, the variable or the dimension level. This can can be achieved
in two ways.</p>
<blockquote>
<div><dl class="docutils">
<dt>-By calling the get()/set() method of an attribute instance. In the</dt>
<dd><p class="first">following example, HDF file &#8216;example.hdf&#8217; is created, and string
attribute &#8216;title&#8217; is attached to the file and given value
&#8216;example&#8217;.</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyhdf.SD</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">SD</span><span class="p">(</span><span class="s">&#39;example.hdf&#39;</span><span class="p">,</span><span class="n">SDC</span><span class="o">.</span><span class="n">WRITE</span><span class="o">|</span><span class="n">SDC</span><span class="o">.</span><span class="n">CREATE</span><span class="p">)</span>  <span class="c"># create file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">att</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">attr</span><span class="p">(</span><span class="s">&#39;title&#39;</span><span class="p">)</span>            <span class="c"># create attribute instance</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">att</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">SDC</span><span class="o">.</span><span class="n">CHAR</span><span class="p">,</span> <span class="s">&#39;example&#39;</span><span class="p">)</span>     <span class="c"># set attribute type and value</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">att</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>                  <span class="c"># get attribute value</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</dd>
<dt>-By handling the attribute like an ordinary Python class attribute.</dt>
<dd><dl class="first last docutils">
<dt>The above example can then be rewritten as follows:</dt>
<dd><div class="first last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyhdf.SD</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">SD</span><span class="p">(</span><span class="s">&#39;example.hdf&#39;</span><span class="p">,</span><span class="n">SDC</span><span class="o">.</span><span class="n">WRITE</span><span class="o">|</span><span class="n">SDC</span><span class="o">.</span><span class="n">CREATE</span><span class="p">)</span>  <span class="c"># create dataset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">title</span> <span class="o">=</span> <span class="s">&#39;example&#39;</span>              <span class="c"># set attribute type and value</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">d</span><span class="o">.</span><span class="n">title</span>                    <span class="c"># get attribute value</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>What has been said above applies as well to multi-valued attributes.</dt>
<dd><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">att</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">attr</span><span class="p">(</span><span class="s">&#39;values&#39;</span><span class="p">)</span>            <span class="c"># With an attribute instance</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">att</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">SDC</span><span class="o">.</span><span class="n">INT32</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>   <span class="c"># Assign 5 ints as attribute value</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">att</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>                         <span class="c"># Get attribute values</span>
<span class="go">[1, 2, 3, 4, 5]</span>
</pre></div>
</div>
<div class="last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>            <span class="c"># As a Python class attribute</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">values</span>                          <span class="c"># Get attribute values</span>
<span class="go">[1, 2, 3, 4, 5]</span>
</pre></div>
</div>
</dd>
</dl>
<p>When the attribute is known by its name , standard functions &#8216;setattr()&#8217;
and &#8216;getattr()&#8217; can be used to replace the dot notation.
Above example becomes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">setattr</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="s">&#39;values&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">getattr</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="s">&#39;values&#39;</span><span class="p">)</span>
<span class="go">[1, 2, 3, 4, 5]</span>
</pre></div>
</div>
<p>Handling a SD attribute like a Python class attribute is admittedly
more natural, and also much simpler. Some control is however lost in
doing so.</p>
<blockquote>
<div><dl class="docutils">
<dt>-Attribute type cannot be specified. pyhdf automatically selects one of</dt>
<dd>three types according to the value(s) assigned to the attribute:
SDC.CHAR if value is a string, SDC.INT32 if all values are integral,
SDC.DOUBLE if one value is a float.</dd>
</dl>
<p>-Consequently, byte values cannot be assigned.
-Attribute properties (length, type, index number) can only be queried</p>
<blockquote>
<div>through methods of an attribute instance.</div></blockquote>
</div></blockquote>
</div>
<div class="section" id="variable-access-low-and-high-level">
<h1>Variable access: low and high level<a class="headerlink" href="#variable-access-low-and-high-level" title="Permalink to this headline">¶</a></h1>
<p>Similarly to attributes, datasets can be read/written in two ways.</p>
<p>The first way is through the get()/set() methods of a dataset instance.
Those methods accept parameters to specify the starting indices, the count
of values to read/write, and the strides along each dimension. For example,
if &#8216;v&#8217; is a 4x4 array:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>                         <span class="c"># complete array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">count</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>  <span class="c"># first row</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">count</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span>  <span class="c"># second and third columns of</span>
<span class="gp">... </span>      <span class="n">stride</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>             <span class="c"># first and third row</span>
</pre></div>
</div>
<p>The second way is by indexing and slicing the variable like a Python
sequence. pyhdf here follows most of the rules used to index and slice
numpy arrays. Thus an HDF dataset can be seen almost as a numpy
array, except that data is read from/written to a file instead of memory.</p>
<p>Extended indexing let you access variable elements with the familiar
[i,j,...] notation, with one index per dimension. For example, if &#8216;m&#8217; is a
rank 3 dataset, one could write:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
<p>When indexing is used to select a dimension in a &#8216;get&#8217; operation, this
dimension is removed from the output array, thus reducing its rank by 1. A
rank 0 array is converted to a scalar. Thus, for a 3x3x3 &#8216;m&#8217; dataset
(rank 3) of integer type :</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>         <span class="c"># a is a 3x3 array (rank 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>       <span class="c"># a is a 3 element array (rank 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>     <span class="c"># a is an integer (rank 0 array becomes a scalar)</span>
</pre></div>
</div>
<p>Had this rule not be followed, m[0,0,0] would have resulted in a single
element array, which could complicate computations.</p>
<p>Extended slice syntax allows slicing HDF datasets along each of its
dimensions, with the specification of optional strides to step through
dimensions at regular intervals. For each dimension, the slice syntax
is: &#8220;i:j[:stride]&#8221;, the stride being optional. As with ordinary slices,
the starting and ending values of a slice can be omitted to refer to the
first and last element, respectively, and the end value can be negative to
indicate that the index is measured relative to the tail instead of the
beginning. Omitted dimensions are assumed to be sliced from beginning to
end. Thus:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>             <span class="c"># treated as &#39;m[0,:,:]&#39;.</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Example above with get()/set() methods can thus be rewritten as follows:</dt>
<dd><div class="first last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[:]</span>             <span class="c"># complete array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span>            <span class="c"># first row</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[::</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>       <span class="c"># second and third columns of first and third row</span>
</pre></div>
</div>
</dd>
<dt>Indexes and slices can be freely mixed, eg:</dt>
<dd><div class="first last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
</dd>
</dl>
<p>Note that, countrary to indexing, a slice never reduces the rank of the
output array, even if its length is 1. For example, given a 3x3x3 &#8216;m&#8217;
dataset:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>         <span class="c"># indexing: a is a 3x3 array (rank 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span>       <span class="c"># slicing: a is a 1x3x3 array (rank 3)</span>
</pre></div>
</div>
<p>As can easily be seen, extended slice syntax is much more elegant and
compact, and offers a few possibilities not easy to achieve with the
get()/sett() methods. Negative indices offer a nice example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>                         <span class="c"># last two rows</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>                       <span class="c"># second and third row</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>                        <span class="c"># last column</span>
</pre></div>
</div>
</div>
<div class="section" id="reading-setting-multivalued-hdf-attributes-and-variables">
<h1>Reading/setting multivalued HDF attributes and variables<a class="headerlink" href="#reading-setting-multivalued-hdf-attributes-and-variables" title="Permalink to this headline">¶</a></h1>
<p>Multivalued HDF attributes are set using a python sequence (tuple or
list). Reading such an attribute returns a python list. The easiest way to
read/set an attribute is by handling it like a Python class attribute
(see &#8220;High level attribute access&#8221;). For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">=</span><span class="n">SD</span><span class="p">(</span><span class="s">&#39;test.hdf&#39;</span><span class="p">,</span><span class="n">SDC</span><span class="o">.</span><span class="n">WRITE</span><span class="o">|</span><span class="n">SDC</span><span class="o">.</span><span class="n">CREATE</span><span class="p">)</span>  <span class="c"># create file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">integers</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>         <span class="c"># define multivalued integer attr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">integers</span>                     <span class="c"># get the attribute value</span>
<span class="go">[1, 2, 3, 4]</span>
</pre></div>
</div>
<p>The easiest way to set multivalued HDF datasets is to assign to a
subset of the dataset, using &#8220;[:]&#8221; to assign to the whole dataset
(see &#8220;High level variable access&#8221;). The assigned value can be a python
sequence, which can be multi-leveled when assigning to a multdimensional
dataset. For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">=</span><span class="n">SD</span><span class="p">(</span><span class="s">&#39;test.hdf&#39;</span><span class="p">,</span><span class="n">SDC</span><span class="o">.</span><span class="n">WRITE</span><span class="o">|</span><span class="n">SDC</span><span class="o">.</span><span class="n">CREATE</span><span class="p">)</span> <span class="c"># create file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v1</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="s">&#39;v1&#39;</span><span class="p">,</span><span class="n">SDC</span><span class="o">.</span><span class="n">INT32</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>         <span class="c"># 3-elem vector</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v1</span><span class="p">[:]</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>                         <span class="c"># assign 3-elem python list</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v2</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="s">&#39;d2&#39;</span><span class="p">,</span><span class="n">SDC</span><span class="o">.</span><span class="n">INT32</span><span class="p">,(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>     <span class="c"># create 3x3 variable</span>
<span class="go">       # The list assigned to v2 is composed</span>
<span class="go">       # of 3 lists, each representing a row of v2.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v2</span><span class="p">[:]</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">13</span><span class="p">],[</span><span class="mi">21</span><span class="p">,</span><span class="mi">22</span><span class="p">,</span><span class="mi">23</span><span class="p">]]</span>
</pre></div>
</div>
<dl class="docutils">
<dt>The assigned value can also be a numpy array. Rewriting example above:</dt>
<dd><div class="first last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">v1</span><span class="o">=</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v2</span><span class="o">=</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">13</span><span class="p">],[</span><span class="mi">21</span><span class="p">,</span><span class="mi">22</span><span class="p">,</span><span class="mi">23</span><span class="p">])</span>
</pre></div>
</div>
</dd>
</dl>
<p>Note how we use indexing expressions &#8216;v1[:]&#8217; and &#8216;v2[:]&#8217; when assigning
using python sequences, and just the variable names when assigning numpy
arrays.</p>
<p>Reading an HDF dataset always returns a numpy array, except if
indexing is used and produces a rank-0 array, in which case a scalar is
returned.</p>
</div>
<div class="section" id="netcdf-files">
<h1>netCDF files<a class="headerlink" href="#netcdf-files" title="Permalink to this headline">¶</a></h1>
<p>Files written in the popular Unidata netCDF format can be read and updated
using the HDF SD API. However, pyhdf cannot create netCDF formatted
files from scratch. The python &#8216;pycdf&#8217; package can be used for that.</p>
<p>When accessing netCDF files through pyhdf, one should be aware of the
following differences between the netCDF and the HDF SD libraries.</p>
<blockquote>
<div><dl class="docutils">
<dt>-Differences in terminology can be confusing. What netCDF calls a</dt>
<dd>&#8216;dataset&#8217; is called a &#8216;file&#8217; or &#8216;SD interface&#8217; in HDF. What HDF calls
a dataset is called a &#8216;variable&#8217; in netCDF parlance.</dd>
<dt>-In the netCDF API, dimensions are defined at the global (netCDF dataset)</dt>
<dd>level. Thus, two netCDF variables defined over dimensions X and Y
necessarily have the same rank and shape.</dd>
<dt>-In the HDF SD API, dimensions are defined at the HDF dataset level,</dt>
<dd>except when they are named. Dimensions with the same name are considered
to be &#8220;shared&#8221; between all the file datasets. They must be of the same
length, and they share all their scales and attributes. For example,
setting an attribute on a shared dimension affects all datasets sharing
that dimension.</dd>
<dt>-When two or more netCDF variables are based on the unlimited dimension,</dt>
<dd>they automatically grow in sync. If variables A and B use the unlimited
dimension, adding &#8220;records&#8221; to A along its unlimited dimension
implicitly adds records in B (which are left in an undefined state and
filled with the fill_value when the file is refreshed).</dd>
<dt>-In HDF, unlimited dimensions behave independently. If HDF datasets A and</dt>
<dd>B are based on an unlimited dimension, adding records to A does not
affect the number of records to B. This is true even if the unlimited
dimensions bear the same name (they do not appear to be &#8220;shared&#8221; as is
the case when the dimensions are fixed).</dd>
</dl>
</div></blockquote>
</div>
<div class="section" id="classes-summary">
<h1>Classes summary<a class="headerlink" href="#classes-summary" title="Permalink to this headline">¶</a></h1>
<p>pyhdf wraps the SD API using different types of python classes:</p>
<blockquote>
<div><dl class="docutils">
<dt>SD     HDF SD interface (almost synonymous with the subset of the</dt>
<dd>HDF file holding all the SD datasets)</dd>
</dl>
<p>SDS    scientific dataset
SDim   dataset dimension
SDAttr attribute (either at the file, dataset or dimension level)
SDC    constants (opening modes, data types, etc)</p>
</div></blockquote>
<p>In more detail:</p>
<blockquote>
<div><dl class="docutils">
<dt>SD     The SD class implements the HDF SD interface as applied to a given</dt>
<dd><p class="first">file. This class encapsulates the &#8220;SD interface&#8221; identifier
(referred to as &#8220;sd_id&#8221; in the C API documentation), and all
the SD API top-level functions.</p>
<p>To create an SD instance, call the SD() constructor.</p>
<dl class="last docutils">
<dt>methods:</dt>
<dd><dl class="first last docutils">
<dt>constructors:</dt>
<dd><dl class="first docutils">
<dt>SD()          open an existing HDF file or create a new one,</dt>
<dd>returning an SD instance</dd>
<dt>attr()        create an SDAttr (attribute) instance to access</dt>
<dd>an existing file attribute or create a new one;
&#8220;dot notation&#8221; can also be used to get and set
an attribute</dd>
</dl>
<p>create()      create a new dataset, returning an SDS instance
select()      locate an existing dataset given its name or</p>
<blockquote class="last">
<div>index number, returning an SDS instance</div></blockquote>
</dd>
<dt>file closing</dt>
<dd><dl class="first last docutils">
<dt>end()         end access to the SD interface and close the</dt>
<dd>HDF file</dd>
</dl>
</dd>
<dt>inquiry</dt>
<dd><dl class="first last docutils">
<dt>attributes()  return a dictionnary describing every global</dt>
<dd>attribute attached to the HDF file</dd>
<dt>datasets()    return a dictionnary describing every dataset</dt>
<dd>stored inside the file</dd>
<dt>info()        get the number of datasets stored in the file</dt>
<dd>and the number of attributes attached to it</dd>
<dt>nametoindex() get a dataset index number given the dataset</dt>
<dd>name</dd>
<dt>reftoindex()  get a dataset index number given the dataset</dt>
<dd>reference number</dd>
</dl>
</dd>
<dt>misc</dt>
<dd><dl class="first last docutils">
<dt>setfillmode() set the fill mode for all the datasets in</dt>
<dd>the file</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>SDAttr The SDAttr class defines an attribute, either at the file (SD),</dt>
<dd><p class="first">dataset (SDS) or dimension (SDim) level. The class encapsulates
the object to which the attribute is attached, and the attribute
name.</p>
<p>To create an SDAttr instance, obtain an instance for an SD (file),
SDS (dataset) or dimension (SDim) object, and call its attr()
method.</p>
<dl class="last docutils">
<dt>NOTE. An attribute can also be read/written like</dt>
<dd>a python class attribute, using the familiar
dot notation. See &#8220;High level attribute access&#8221;.</dd>
<dt>methods:</dt>
<dd><dl class="first last docutils">
<dt>read/write value</dt>
<dd>get()         get the attribute value
set()         set the attribute value</dd>
<dt>inquiry</dt>
<dd><p class="first">index()       get the attribute index number
info()        get the attribute name, type and number of</p>
<blockquote class="last">
<div>values</div></blockquote>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>SDC    The SDC class holds contants defining file opening modes and</dt>
<dd><p class="first">data types. Constants are named after their C API counterparts.</p>
<blockquote class="last">
<div><dl class="docutils">
<dt>file opening modes:</dt>
<dd>SDC.CREATE      create file if non existent
SDC.READ        read-only mode
SDC.TRUNC       truncate file if already exists
SDC.WRITE       read-write mode</dd>
<dt>data types:</dt>
<dd>SDC.CHAR        8-bit character
SDC.CHAR8       8-bit character
SDC.UCHAR       unsigned 8-bit integer
SDC.UCHAR8      unsigned 8-bit integer
SDC.INT8        signed 8-bit integer
SDC.UINT8       unsigned 8-bit integer
SDC.INT16       signed 16-bit integer
SDC.UINT16      unsigned 16-bit intege
SDC.INT32       signed 32-bit integer
SDC.UINT32      unsigned 32-bit integer
SDC.FLOAT32     32-bit floating point
SDC.FLOAT64     64-bit floaring point</dd>
<dt>dataset fill mode:</dt>
<dd>SDC.FILL
SDC.NOFILL</dd>
<dt>dimension:</dt>
<dd>SDC.UNLIMITED   dimension can grow dynamically</dd>
<dt>data compression:</dt>
<dd>SDC.COMP_NONE
SDC.COMP_RLE
SDC.COMP_NBIT
SDC.COMP_SKPHUFF
SDC.COMP_DEFLATE
SDC.COMP_SZIP
SDC.COMP_SZIP_EC
SDC.COMP_SZIP_NN
SDC.COMP_SZIP_RAW</dd>
</dl>
</div></blockquote>
</dd>
</dl>
<p>SDS    The SDS class implements an HDF scientific dataset (SDS) object.</p>
<blockquote>
<div><p>To create an SDS instance, call the create() or select() methods
of an SD instance.</p>
<dl class="docutils">
<dt>methods:</dt>
<dd><dl class="first last docutils">
<dt>constructors</dt>
<dd><dl class="first last docutils">
<dt>attr()        create an SDAttr (attribute) instance to access</dt>
<dd>an existing dataset attribute or create a
new one; &#8220;dot notation&#8221; can also be used to get
and set an attribute</dd>
<dt>dim()         return an SDim (dimension) instance for a given</dt>
<dd>dataset dimension, given the dimension index
number</dd>
</dl>
</dd>
<dt>dataset closing</dt>
<dd>endaccess()   terminate access to the dataset</dd>
<dt>inquiry</dt>
<dd><dl class="first docutils">
<dt>attributes()  return a dictionnary describing every </dt>
<dd>attribute defined on the dataset</dd>
</dl>
<p>checkempty()  determine whether the dataset is empty
dimensions()  return a dictionnary describing all the</p>
<blockquote>
<div>dataset dimensions</div></blockquote>
<dl class="docutils">
<dt>info()        get the dataset name, rank, dimension lengths,</dt>
<dd>data type and number of attributes</dd>
<dt>iscoordvar()  determine whether the dataset is a coordinate</dt>
<dd>variable (holds a dimension scale)</dd>
<dt>isrecord()    determine whether the dataset is appendable</dt>
<dd>(the dataset dimension 0 is unlimited)</dd>
</dl>
<p class="last">ref()         get the dataset reference number</p>
</dd>
<dt>reading/writing data values</dt>
<dd><p class="first">get()         read data from the dataset
set()         write data to the dataset</p>
<blockquote class="last">
<div>A dataset can also be read/written using the
familiar index and slice notation used to
access python sequences. See &#8220;High level
variable access&#8221;.</div></blockquote>
</dd>
<dt>reading/writing  standard attributes</dt>
<dd><dl class="first docutils">
<dt>getcal()       get the dataset calibration coefficients:</dt>
<dd>scale_factor, scale_factor_err, add_offset,
add_offset_err, calibrated_nt</dd>
<dt>getdatastrs()  get the dataset standard string attributes:</dt>
<dd>long_name, units, format, coordsys</dd>
<dt>getfillvalue() get the dataset fill value:</dt>
<dd>_FillValue</dd>
<dt>getrange()     get the dataset min and max values:</dt>
<dd>valid_range</dd>
</dl>
<p class="last">setcal()       set the dataset calibration coefficients
setdatastrs()  set the dataset standard string attributes
setfillvalue() set the dataset fill value
setrange()     set the dataset min and max values</p>
</dd>
<dt>compression</dt>
<dd>getcompress()  get info about the dataset compression type and mode
setcompress()  set the dataset compression type and mode</dd>
<dt>misc</dt>
<dd>setexternalfile()  store the dataset in an external file</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>SDim   The SDdim class implements a dimension object.</p>
<blockquote>
<div><p>To create an SDim instance, call the dim() method of an SDS
(dataset) instance.</p>
<dl class="docutils">
<dt>Methods:</dt>
<dd><dl class="first last docutils">
<dt>constructors</dt>
<dd><dl class="first last docutils">
<dt>attr()         create an SDAttr (attribute) instance to access</dt>
<dd>an existing dimension attribute or create a
new one; &#8220;dot notation&#8221; can also be used to
get and set an attribute</dd>
</dl>
</dd>
<dt>inquiry</dt>
<dd><dl class="first docutils">
<dt>attributes()   return a dictionnary describing every </dt>
<dd>attribute defined on the dimension</dd>
<dt>info()         get the dimension name, length, scale data type</dt>
<dd>and number of attributes</dd>
</dl>
<p class="last">length()       return the current dimension length</p>
</dd>
<dt>reading/writing dimension data</dt>
<dd>getscale()     get the dimension scale values
setname()      set the dimension name
setscale()     set the dimension scale values</dd>
<dt>reading/writing standard attributes</dt>
<dd><dl class="first docutils">
<dt>getstrs()      get the dimension standard string attributes:</dt>
<dd>long_name, units, format</dd>
</dl>
<p class="last">setstrs()      set the dimension standard string attributes</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
</div>
<div class="section" id="data-types">
<h1>Data types<a class="headerlink" href="#data-types" title="Permalink to this headline">¶</a></h1>
<p>Data types come into play when first defining datasets and their attributes,
and later when querying the definition of those objects.
Data types are specified using the symbolic constants defined inside the
SDC class of the SD module.</p>
<blockquote>
<div><ul class="simple">
<li>CHAR and CHAR8 (equivalent): an 8-bit character.</li>
<li>UCHAR, UCHAR8 and UINT8 (equivalent): unsigned 8-bit values (0 to 255)</li>
<li>INT8:    signed 8-bit values (-128 to 127)</li>
<li>INT16:   signed 16-bit values</li>
<li>UINT16:  unsigned 16 bit values</li>
<li>INT32:   signed 32 bit values</li>
<li>UINT32:  unsigned 32 bit values</li>
<li>FLOAT32: 32 bit floating point values (C floats)</li>
<li>FLOAT64: 64 bit floating point values (C doubles)</li>
</ul>
</div></blockquote>
<p>There is no explicit &#8220;string&#8221; type. To simulate a string, set the 
type to CHAR, and set the length to a value of &#8216;n&#8217; &gt; 1. This creates and
&#8220;array of characters&#8221;, close to a string (except that strings will always
be of length &#8216;n&#8217;, right-padded with spaces if necessary).</p>
</div>
<div class="section" id="programming-models">
<h1>Programming models<a class="headerlink" href="#programming-models" title="Permalink to this headline">¶</a></h1>
</div>
<div class="section" id="writing">
<h1>Writing<a class="headerlink" href="#writing" title="Permalink to this headline">¶</a></h1>
<p>The following code can be used as a model to create an SD dataset.
It shows how to use the most important functionnalities
of the SD interface needed to initialize a dataset.
A real program should of course add error handling.</p>
<blockquote>
<div><p># Import SD and numpy.
from pyhdf.SD import *
from numpy import *</p>
<p>fileName = &#8216;template.hdf&#8217;
# Create HDF file.
hdfFile = SD(fileName ,SDC.WRITE|SDC.CREATE)
# Assign a few attributes at the file level
hdfFile.author = &#8216;It is me...&#8217;
hdfFile.priority = 2
# Create a dataset named &#8216;d1&#8217; to hold a 3x3 float array.
d1 = hdfFile.create(&#8216;d1&#8217;, SDC.FLOAT32, (3,3))
# Set some attributs on &#8216;d1&#8217;
d1.description = &#8216;Sample 3x3 float array&#8217;
d1.units = &#8216;celsius&#8217;
# Name &#8216;d1&#8217; dimensions and assign them attributes.
dim1 = d1.dim(0)
dim2 = d1.dim(1)
dim1.setname(&#8216;width&#8217;)
dim2.setname(&#8216;height&#8217;)
dim1.units = &#8216;m&#8217;
dim2.units = &#8216;cm&#8217;
# Assign values to &#8216;d1&#8217;
d1[0]  = (14.5, 12.8, 13.0)  # row 1
d1[1:] = ((-1.3, 0.5, 4.8),  # row 2 and</p>
<blockquote>
<div>(3.1, 0.0, 13.8))  # row 3</div></blockquote>
<p># Close dataset
d1.endaccess()
# Close file
hdfFile.end()</p>
</div></blockquote>
</div>
<div class="section" id="reading">
<h1>Reading<a class="headerlink" href="#reading" title="Permalink to this headline">¶</a></h1>
<p>The following code, which reads the dataset created above, can also serve as
a model for any program which needs to access an SD dataset.</p>
<blockquote>
<div><p># Import SD and numpy.
from pyhdf.SD import *
from numpy import *</p>
<p>fileName = &#8216;template.hdf&#8217;
# Open file in read-only mode (default)
hdfFile = SD(fileName)
# Display attributes.
print &#8220;file:&#8221;, fileName
print &#8220;author:&#8221;, hdfFile.author
print &#8220;priority:&#8221;, hdfFile.priority
# Open dataset &#8216;d1&#8217;
d1 = hdfFile.select(&#8216;d1&#8217;)
# Display dataset attributes.
print &#8220;dataset:&#8221;, &#8216;d1&#8217;
print &#8220;description:&#8221;,d1.description
print &#8220;units:&#8221;, d1.units
# Display dimensions info.
dim1 = d1.dim(0)
dim2 = d1.dim(1)
print &#8220;dimensions:&#8221;
print &#8220;dim1: name=&#8221;, dim1.info()[0], 
print &#8220;length=&#8221;, dim1.length(), 
print &#8220;units=&#8221;, dim1.units
print &#8220;dim2: name=&#8221;, dim2.info()[0], 
print &#8220;length=&#8221;, dim2.length(), 
print &#8220;units=&#8221;, dim2.units
# Show dataset values
print d1[:]
# Close dataset
d1.endaccess()
# Close file
hdfFile.end()</p>
</div></blockquote>
</div>
<div class="section" id="examples">
<h1>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h1>
</div>
<div class="section" id="example-1">
<h1>Example-1<a class="headerlink" href="#example-1" title="Permalink to this headline">¶</a></h1>
<p>The following simple example exercises some important pyhdf.SD methods. It
shows how to create an HDF dataset, define attributes and dimensions,
create variables, and assign their contents.</p>
<p>Suppose we have a series of text files each defining a 2-dimensional real-
valued matrix. First line holds the matrix dimensions, and following lines
hold matrix values, one row per line. The following procedure will load
into an HDF dataset the contents of any one of those text files. The
procedure computes the matrix min and max values, storing them as
dataset attributes. It also assigns to the variable the group of
attributes passed as a dictionnary by the calling program. Note how simple
such an assignment becomes with pyhdf: the dictionnary can contain any
number of attributes, of different types, single or multi-valued. Doing
the same in a conventional language would be a much more challenging task.</p>
<p>Error checking is minimal, to keep example as simple as possible
(admittedly a rather poor excuse ...).</p>
<p>from numpy import *
from pyhdf.SD import *</p>
<p>import os</p>
<p>def txtToHDF(txtFile, hdfFile, varName, attr):</p>
<blockquote>
<div><dl class="docutils">
<dt>try:  # Catch pyhdf errors</dt>
<dd><p class="first"># Open HDF file in update mode, creating it if non existent.
d = SD(hdfFile, SDC.WRITE|SDC.CREATE)
# Open text file and get matrix dimensions on first line.
txt = open(txtFile)
ni, nj = map(int, txt.readline().split())
# Define an HDF dataset of 32-bit floating type (SDC.FLOAT32)
# with those dimensions.
v = d.create(varName, SDC.FLOAT32, (ni, nj))
# Assign attributes passed as argument inside dict &#8216;attr&#8217;.
for attrName in attr.keys():</p>
<blockquote>
<div>setattr(v, attrName, attr[attrName])</div></blockquote>
<p># Load variable with lines of data. Compute min and max
# over the whole matrix.
i = 0
while i &lt; ni:</p>
<blockquote>
<div><p>elems = map(float, txt.readline().split())
v[i] = elems  # load row i
minE = min(elems)
maxE = max(elems)
if i:</p>
<blockquote>
<div>minVal = min(minVal, minE)
maxVal = max(maxVal, maxE)</div></blockquote>
<dl class="docutils">
<dt>else:</dt>
<dd>minVal = minE
maxVal = maxE</dd>
</dl>
<p>i += 1</p>
</div></blockquote>
<p class="last"># Set variable min and max attributes.
v.minVal = minVal
v.maxVal = maxVal
# Close dataset and file objects (not really necessary, since
# closing is automatic when objects go out of scope.
v.endaccess()
d.end()
txt.close()</p>
</dd>
<dt>except HDF4Error, msg:</dt>
<dd>print &#8220;HDF4Error:&#8221;, msg</dd>
</dl>
</div></blockquote>
<p>We could now call the procedure as follows:</p>
<blockquote>
<div><p>hdfFile  = &#8216;table.hdf&#8217;
try:  # Delete if exists.</p>
<blockquote>
<div>os.remove(hdfFile)</div></blockquote>
<dl class="docutils">
<dt>except:</dt>
<dd>pass</dd>
</dl>
<p># Load contents of file &#8216;temp.txt&#8217; into dataset &#8216;temperature&#8217;
# an assign the attributes &#8216;title&#8217;, &#8216;units&#8217; and &#8216;valid_range&#8217;.
txtToHDF(&#8216;temp.txt&#8217;, hdfFile, &#8216;temperature&#8217;,</p>
<blockquote>
<div><dl class="docutils">
<dt>{&#8216;title&#8217; <span class="classifier-delimiter">:</span> <span class="classifier">&#8216;temperature matrix&#8217;,</span></dt>
<dd>&#8216;units&#8217;      : &#8216;celsius&#8217;,
&#8216;valid_range&#8217;: (-2.8,27.0)})</dd>
</dl>
</div></blockquote>
<p># Load contents of file &#8216;depth.txt&#8217; into dataset &#8216;depth&#8217;
# and assign the same attributes as above.
txtToHDF(&#8216;depth.txt&#8217;, hdfFile, &#8216;depth&#8217;,</p>
<blockquote>
<div><dl class="docutils">
<dt>{&#8216;title&#8217; <span class="classifier-delimiter">:</span> <span class="classifier">&#8216;depth matrix&#8217;,</span></dt>
<dd>&#8216;units&#8217;      : &#8216;meters&#8217;,
&#8216;valid_range&#8217;: (0, 500.0)})</dd>
</dl>
</div></blockquote>
</div></blockquote>
</div>
<div class="section" id="example-2">
<h1>Example 2<a class="headerlink" href="#example-2" title="Permalink to this headline">¶</a></h1>
<p>This example shows a usefull python program that will display the
structure of the SD component of any HDF file whose name is given on
the command line. After the HDF file is opened, high level inquiry methods
are called to obtain dictionnaries descrybing attributes, dimensions and
datasets. The rest of the program mostly consists in nicely formatting
the contents of those dictionaries.</p>
<p>import sys
from pyhdf.SD import *
from numpy import *</p>
<p># Dictionnary used to convert from a numeric data type to its symbolic
# representation
typeTab = {</p>
<blockquote>
<div>SDC.CHAR:    &#8216;CHAR&#8217;,
SDC.CHAR8:   &#8216;CHAR8&#8217;,
SDC.UCHAR8:  &#8216;UCHAR8&#8217;,
SDC.INT8:    &#8216;INT8&#8217;,
SDC.UINT8:   &#8216;UINT8&#8217;,
SDC.INT16:   &#8216;INT16&#8217;,
SDC.UINT16:  &#8216;UINT16&#8217;,
SDC.INT32:   &#8216;INT32&#8217;,
SDC.UINT32:  &#8216;UINT32&#8217;,
SDC.FLOAT32: &#8216;FLOAT32&#8217;,
SDC.FLOAT64: &#8216;FLOAT64&#8217;
}</div></blockquote>
<p>printf = sys.stdout.write</p>
<dl class="docutils">
<dt>def eol(n=1):</dt>
<dd>printf(&#8220;%s&#8221; % chr(10) * n)</dd>
</dl>
<p>hdfFile = sys.argv[1]    # Get first command line argument</p>
<dl class="docutils">
<dt>try:  # Catch pyhdf.SD errors</dt>
<dd><p class="first"># Open HDF file named on the command line
f = SD(hdfFile)
# Get global attribute dictionnary
attr = f.attributes(full=1)
# Get dataset dictionnary
dsets = f.datasets()</p>
<p># File name, number of attributes and number of variables.
printf(&#8220;FILE INFO&#8221;); eol()
printf(&#8220;&#8212;&#8212;&#8212;&#8212;-&#8221;); eol()
printf(&#8220;%-25s%s&#8221; % (&#8220;File:&#8221;, hdfFile)); eol()
printf(&#8220;%-25s%d&#8221; % (&#8221;  file attributes:&#8221;, len(attr))); eol()
printf(&#8220;%-25s%d&#8221; % (&#8221;  datasets:&#8221;, len(dsets))); eol()
eol();</p>
<p># Global attribute table.
if len(attr) &gt; 0:</p>
<blockquote>
<div><p>printf(&#8220;File attributes&#8221;); eol(2)
printf(&#8221;  name                 idx type    len value&#8221;); eol()
printf(&#8221;  &#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211; &#8212; &#8212;&#8212;- &#8212; &#8212;&#8211;&#8221;); eol()
# Get list of attribute names and sort them lexically
attNames = attr.keys()
attNames.sort()
for name in attNames:</p>
<blockquote>
<div><dl class="docutils">
<dt>t = attr[name]</dt>
<dd># t[0] is the attribute value
# t[1] is the attribute index number
# t[2] is the attribute type
# t[3] is the attribute length</dd>
<dt>printf(&#8221;  %-20s %3d %-7s %3d %s&#8221; %</dt>
<dd>(name, t[1], typeTab[t[2]], t[3], t[0])); eol()</dd>
</dl>
</div></blockquote>
<p>eol()</p>
</div></blockquote>
<p># Dataset table
if len(dsets) &gt; 0:</p>
<blockquote>
<div><p>printf(&#8220;Datasets (idx:index num, na:n attributes, cv:coord var)&#8221;); eol(2)
printf(&#8221;  name                 idx type    na cv dimension(s)&#8221;); eol()
printf(&#8221;  &#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211; &#8212; &#8212;&#8212;- &#8211; &#8211; &#8212;&#8212;&#8212;&#8212;&#8221;); eol()
# Get list of dataset names and sort them lexically
dsNames = dsets.keys()
dsNames.sort()
for name in dsNames:</p>
<blockquote>
<div><p># Get dataset instance
ds = f.select(name)
# Retrieve the dictionary of dataset attributes so as
# to display their number
vAttr = ds.attributes()
t = dsets[name]</p>
<blockquote>
<div># t[0] is a tuple of dimension names
# t[1] is a tuple of dimension lengths
# t[2] is the dataset type
# t[3] is the dataset index number</div></blockquote>
<dl class="docutils">
<dt>printf(&#8221;  %-20s %3d %-7s %2d %-2s &#8221; %</dt>
<dd><dl class="first last docutils">
<dt>(name, t[3], typeTab[t[2]], len(vAttr),</dt>
<dd>ds.iscoordvar() and &#8216;X&#8217; or &#8216;&#8217;))</dd>
</dl>
</dd>
</dl>
<p># Display dimension info.
n = 0
for d in t[0]:</p>
<blockquote>
<div>printf(&#8220;%s%s(%d)&#8221; % (n &gt; 0 and &#8216;, &#8216; or &#8216;&#8217;, d, t[1][n]))
n += 1</div></blockquote>
<p>eol()</p>
</div></blockquote>
<p>eol()</p>
</div></blockquote>
<p># Dataset info.
if len(dsNames) &gt; 0:</p>
<blockquote class="last">
<div><p>printf(&#8220;DATASET INFO&#8221;); eol()
printf(&#8220;&#8212;&#8212;&#8212;&#8212;-&#8221;); eol(2)
for name in dsNames:</p>
<blockquote>
<div><p># Access the dataset
dsObj = f.select(name)
# Get dataset attribute dictionnary
dsAttr = dsObj.attributes(full=1)
if len(dsAttr) &gt; 0:</p>
<blockquote>
<div><p>printf(&#8220;%s attributes&#8221; % name); eol(2)
printf(&#8221;  name                 idx type    len value&#8221;); eol()
printf(&#8221;  &#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211; &#8212; &#8212;&#8212;- &#8212; &#8212;&#8211;&#8221;); eol()
# Get the list of attribute names and sort them alphabetically.
attNames = dsAttr.keys()
attNames.sort()
for nm in attNames:</p>
<blockquote>
<div><dl class="docutils">
<dt>t = dsAttr[nm]</dt>
<dd># t[0] is the attribute value
# t[1] is the attribute index number
# t[2] is the attribute type
# t[3] is the attribute length</dd>
<dt>printf(&#8221;  %-20s %3d %-7s %3d %s&#8221; %</dt>
<dd>(nm, t[1], typeTab[t[2]], t[3], t[0])); eol()</dd>
</dl>
</div></blockquote>
<p>eol()</p>
</div></blockquote>
<p># Get dataset dimension dictionnary
dsDim = dsObj.dimensions(full=1)
if len(dsDim) &gt; 0:</p>
<blockquote>
<div><p>printf (&#8220;%s dimensions&#8221; % name); eol(2)
printf(&#8221;  name                 idx len   unl type    natt&#8221;);eol()
printf(&#8221;  &#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211; &#8212; &#8212;&#8211; &#8212; &#8212;&#8212;- &#8212;-&#8221;);eol()
# Get the list of dimension names and sort them alphabetically.
dimNames = dsDim.keys()
dimNames.sort()
for nm in dimNames:</p>
<blockquote>
<div><dl class="docutils">
<dt>t = dsDim[nm]</dt>
<dd># t[0] is the dimension length
# t[1] is the dimension index number
# t[2] is 1 if the dimension is unlimited, 0 if not
# t[3] is the the dimension scale type, 0 if no scale
# t[4] is the number of attributes</dd>
<dt>printf(&#8221;  %-20s %3d %5d  %s  %-7s %4d&#8221; %</dt>
<dd><dl class="first last docutils">
<dt>(nm, t[1], t[0], t[2] and &#8220;X&#8221; or &#8221; &#8221;, </dt>
<dd>t[3] and typeTab[t[3]] or &#8220;&#8221;, t[4])); eol()</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>eol()</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</dd>
<dt>except HDF4Error, msg:</dt>
<dd>print &#8220;HDF4Error&#8221;, msg</dd>
</dl>
<dl class="class">
<dt id="pyhdf.SD.SD">
<em class="property">class </em><tt class="descclassname">pyhdf.SD.</tt><tt class="descname">SD</tt><big>(</big><em>path</em>, <em>mode=1</em><big>)</big><a class="headerlink" href="#pyhdf.SD.SD" title="Permalink to this definition">¶</a></dt>
<dd><p>The SD class implements an HDF SD interface.
To instantiate an SD class, call the SD() constructor.
To set attributes on an SD instance, call the SD.attr()
method to create an attribute instance, then call the methods
of this instance.</p>
<dl class="method">
<dt id="pyhdf.SD.SD.attr">
<tt class="descname">attr</tt><big>(</big><em>name_or_index</em><big>)</big><a class="headerlink" href="#pyhdf.SD.SD.attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an SDAttr instance representing a global
attribute (defined at the level of the SD interface).</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>name_or_index   attribute name or index number; if a name is</dt>
<dd>given, the attribute may not exist; in that
case, it will be created when the SDAttr
instance set() method is called</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>SDAttr instance for the attribute. Call the methods of this
class to query, read or set the attribute.</dd>
</dl>
<p>C library equivalent : no equivalent</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.SD.SD.attributes">
<tt class="descname">attributes</tt><big>(</big><em>full=0</em><big>)</big><a class="headerlink" href="#pyhdf.SD.SD.attributes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionnary describing every global
attribute attached to the SD interface.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>full      true to get complete info about each attribute</dt>
<dd>false to report only each attribute value</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><p class="first">Empty dictionnary if no global attribute defined
Otherwise, dictionnary where each key is the name of a
global attribute. If parameter &#8216;full&#8217; is false,
key value is the attribute value. If &#8216;full&#8217; is true,
key value is a tuple with the following elements:</p>
<blockquote class="last">
<div><ul class="simple">
<li>attribute value</li>
<li>attribute index number</li>
<li>attribute type</li>
<li>attribute length</li>
</ul>
</div></blockquote>
</dd>
</dl>
<p>C library equivalent : no equivalent</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.SD.SD.create">
<tt class="descname">create</tt><big>(</big><em>name</em>, <em>data_type</em>, <em>dim_sizes</em><big>)</big><a class="headerlink" href="#pyhdf.SD.SD.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a dataset.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">name           dataset name
data_type      type of the data, set to one of the SDC.xxx</p>
<blockquote>
<div>constants;</div></blockquote>
<dl class="last docutils">
<dt>dim_sizes      lengths of the dataset dimensions; a one-</dt>
<dd><p class="first">dimensional array is specified with an integer,
an n-dimensional array with an n-element sequence
of integers; the length of the first dimension can
be set to SDC.UNLIMITED to create an unlimited
dimension (a &#8220;record&#8221; variable).</p>
<p class="last">IMPORTANT:  netCDF and HDF differ in the way
the UNLIMITED dimension is handled. In netCDF,
all variables of a dataset with an unlimited
dimension grow in sync, eg adding a record to
a variable will implicitly extend other record
variables. In HDF, each record variable grows
independently of each other.</p>
</dd>
</dl>
</dd>
<dt>Returns: </dt>
<dd>SDS instance for the dataset</dd>
</dl>
<p>C library equivalent : SDcreate</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.SD.SD.datasets">
<tt class="descname">datasets</tt><big>(</big><big>)</big><a class="headerlink" href="#pyhdf.SD.SD.datasets" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionnary describing all the file datasets.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>no argument</dd>
<dt>Returns:</dt>
<dd><p class="first">Empty dictionnary if no dataset is defined.
Otherwise, dictionnary whose keys are the file dataset names,
and values are tuples describing the corresponding datasets.
Each tuple holds the following elements in order:</p>
<blockquote class="last">
<div><dl class="docutils">
<dt>-tuple holding the names of the dimensions defining the</dt>
<dd>dataset coordinate axes</dd>
<dt>-tuple holding the dataset shape (dimension lengths);</dt>
<dd>if a dimension is unlimited, the reported length corresponds
to the dimension current length</dd>
</dl>
<p>-dataset type
-dataset index number</p>
</div></blockquote>
</dd>
</dl>
<p>C library equivalent : no equivalent</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.SD.SD.end">
<tt class="descname">end</tt><big>(</big><big>)</big><a class="headerlink" href="#pyhdf.SD.SD.end" title="Permalink to this definition">¶</a></dt>
<dd><p>End access to the SD interface and close the HDF file.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>no argument</dd>
<dt>Returns: </dt>
<dd>None</dd>
</dl>
<p>The instance should not be used afterwards.
The &#8216;end()&#8217; method is implicitly called when the
SD instance is deleted.</p>
<p>C library equivalent : SDend</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.SD.SD.info">
<tt class="descname">info</tt><big>(</big><big>)</big><a class="headerlink" href="#pyhdf.SD.SD.info" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve information about the SD interface.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>no argument</dd>
<dt>Returns: </dt>
<dd><dl class="first last docutils">
<dt>2-element tuple holding:</dt>
<dd>number of datasets inside the file
number of file attributes</dd>
</dl>
</dd>
</dl>
<p>C library equivalent : SDfileinfo</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.SD.SD.nametoindex">
<tt class="descname">nametoindex</tt><big>(</big><em>sds_name</em><big>)</big><a class="headerlink" href="#pyhdf.SD.SD.nametoindex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index number of a dataset given the dataset name.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>sds_name  : dataset name</dd>
<dt>Returns:</dt>
<dd>index number of the dataset</dd>
</dl>
<p>C library equivalent : SDnametoindex</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.SD.SD.reftoindex">
<tt class="descname">reftoindex</tt><big>(</big><em>sds_ref</em><big>)</big><a class="headerlink" href="#pyhdf.SD.SD.reftoindex" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index number of a dataset given the dataset 
reference number.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>sds_ref : dataset reference number</dd>
<dt>Returns:</dt>
<dd>dataset index number</dd>
</dl>
<p>C library equivalent : SDreftoindex</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.SD.SD.select">
<tt class="descname">select</tt><big>(</big><em>name_or_index</em><big>)</big><a class="headerlink" href="#pyhdf.SD.SD.select" title="Permalink to this definition">¶</a></dt>
<dd><p>Locate a dataset.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>name_or_index  dataset name or index number</dd>
<dt>Returns: </dt>
<dd>SDS instance for the dataset</dd>
</dl>
<p>C library equivalent : SDselect</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.SD.SD.setfillmode">
<tt class="descname">setfillmode</tt><big>(</big><em>fill_mode</em><big>)</big><a class="headerlink" href="#pyhdf.SD.SD.setfillmode" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the fill mode for all the datasets in the file.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>fill_mode <span class="classifier-delimiter">:</span> <span class="classifier">fill mode; one of :</span></dt>
<dd><dl class="first last docutils">
<dt>SDC.FILL   write the fill value to all the datasets</dt>
<dd>of the file by default</dd>
<dt>SDC.NOFILL do not write fill values to all datasets</dt>
<dd>of the file by default</dd>
</dl>
</dd>
</dl>
</dd>
<dt>Returns: </dt>
<dd>previous fill mode value</dd>
</dl>
<p>C library equivalent: SDsetfillmode</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyhdf.SD.SDAttr">
<em class="property">class </em><tt class="descclassname">pyhdf.SD.</tt><tt class="descname">SDAttr</tt><big>(</big><em>obj</em>, <em>index_or_name</em><big>)</big><a class="headerlink" href="#pyhdf.SD.SDAttr" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pyhdf.SD.SDAttr.get">
<tt class="descname">get</tt><big>(</big><big>)</big><a class="headerlink" href="#pyhdf.SD.SDAttr.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the attribute value.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>no argument</dd>
<dt>Returns: </dt>
<dd>attribute value(s); a list is returned if the attribute
is made up of more than one value, except in the case of a 
string-valued attribute (data type SDC.CHAR8) where the 
values are returned as a string</dd>
</dl>
<p>C library equivalent : SDreadattr</p>
<p>Attributes can also be read like ordinary python attributes,
using the dot notation. See &#8220;High level attribute access&#8221;.</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.SD.SDAttr.index">
<tt class="descname">index</tt><big>(</big><big>)</big><a class="headerlink" href="#pyhdf.SD.SDAttr.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the attribute index number.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>no argument</dd>
<dt>Returns: </dt>
<dd>attribute index number (starting at 0)</dd>
</dl>
<p>C library equivalent : SDfindattr</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.SD.SDAttr.info">
<tt class="descname">info</tt><big>(</big><big>)</big><a class="headerlink" href="#pyhdf.SD.SDAttr.info" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve info about the attribute : name, data type and
number of values.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>no argument</dd>
<dt>Returns: </dt>
<dd><dl class="first last docutils">
<dt>3-element tuple holding:</dt>
<dd><p class="first">-attribute name
-attribute data type (see constants SDC.xxx)
-number of values in the attribute; for a string-valued</p>
<blockquote class="last">
<div>attribute (data type SDC.CHAR8), the number of values
corresponds to the string length</div></blockquote>
</dd>
</dl>
</dd>
</dl>
<p>C library equivalent : SDattrinfo</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.SD.SDAttr.set">
<tt class="descname">set</tt><big>(</big><em>data_type</em>, <em>values</em><big>)</big><a class="headerlink" href="#pyhdf.SD.SDAttr.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Update/Create a new attribute and set its value(s).</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">data_type    : attribute data type (see constants SDC.xxx)
values       : attribute value(s); specify a list to create</p>
<blockquote class="last">
<div>a multi-valued attribute; a string valued
attribute can be created by setting &#8216;data_type&#8217;
to SDC.CHAR8 and &#8216;values&#8217; to the corresponding
string</div></blockquote>
</dd>
<dt>Returns: </dt>
<dd>None</dd>
</dl>
<p>C library equivalent : SDsetattr</p>
<p>Attributes can also be written like ordinary python attributes,
using the dot notation. See &#8220;High level attribute access&#8221;.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyhdf.SD.SDC">
<em class="property">class </em><tt class="descclassname">pyhdf.SD.</tt><tt class="descname">SDC</tt><a class="headerlink" href="#pyhdf.SD.SDC" title="Permalink to this definition">¶</a></dt>
<dd><p>The SDC class holds contants defining opening modes and data types.</p>
<dl class="docutils">
<dt>file opening modes:</dt>
<dd>SDC.CREATE     4    create file if non existent
SDC.READ       1    read-only mode
SDC.TRUNC    256    truncate file if already exists
SDC.WRITE      2    read-write mode</dd>
<dt>data types:</dt>
<dd>SDC.CHAR       4    8-bit character
SDC.CHAR8      4    8-bit character
SDC.UCHAR      3    unsigned 8-bit integer
SDC.UCHAR8     3    unsigned 8-bit integer
SDC.INT8      20    signed 8-bit integer
SDC.UINT8     21    unsigned 8-bit integer
SDC.INT16     22    signed 16-bit integer
SDC.UINT16    23    unsigned 16-bit intege
SDC.INT32     24    signed 32-bit integer
SDC.UINT32    25    unsigned 32-bit integer
SDC.FLOAT32    5    32-bit floating point
SDC.FLOAT64    6    64-bit floaring point</dd>
<dt>dataset fill mode:</dt>
<dd>SDC.FILL       0
SDC.NOFILL   256</dd>
<dt>dimension:</dt>
<dd>SDC.UNLIMITED  0    dimension can grow dynamically</dd>
<dt>data compression:</dt>
<dd><p class="first">SDC.COMP_NONE      0
SDC.COMP_RLE       1
SDC.COMP_NBIT      2
SDC.COMP_SKPHUFF   3
SDC.COMP_DEFLATE   4
SDC.COMP_SZIP      5</p>
<p class="last">SDC.COMP_SZIP_EC     4
SDC.COMP_SZIP_NN    32
SDC.COMP_SZIP_RAW  128</p>
</dd>
</dl>
<dl class="attribute">
<dt id="pyhdf.SD.SDC.CHAR">
<tt class="descname">CHAR</tt><em class="property"> = 4</em><a class="headerlink" href="#pyhdf.SD.SDC.CHAR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyhdf.SD.SDC.CHAR8">
<tt class="descname">CHAR8</tt><em class="property"> = 4</em><a class="headerlink" href="#pyhdf.SD.SDC.CHAR8" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyhdf.SD.SDC.COMP_DEFLATE">
<tt class="descname">COMP_DEFLATE</tt><em class="property"> = 4</em><a class="headerlink" href="#pyhdf.SD.SDC.COMP_DEFLATE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyhdf.SD.SDC.COMP_NBIT">
<tt class="descname">COMP_NBIT</tt><em class="property"> = 2</em><a class="headerlink" href="#pyhdf.SD.SDC.COMP_NBIT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyhdf.SD.SDC.COMP_NONE">
<tt class="descname">COMP_NONE</tt><em class="property"> = 0</em><a class="headerlink" href="#pyhdf.SD.SDC.COMP_NONE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyhdf.SD.SDC.COMP_RLE">
<tt class="descname">COMP_RLE</tt><em class="property"> = 1</em><a class="headerlink" href="#pyhdf.SD.SDC.COMP_RLE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyhdf.SD.SDC.COMP_SKPHUFF">
<tt class="descname">COMP_SKPHUFF</tt><em class="property"> = 3</em><a class="headerlink" href="#pyhdf.SD.SDC.COMP_SKPHUFF" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyhdf.SD.SDC.COMP_SZIP">
<tt class="descname">COMP_SZIP</tt><em class="property"> = 5</em><a class="headerlink" href="#pyhdf.SD.SDC.COMP_SZIP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyhdf.SD.SDC.COMP_SZIP_EC">
<tt class="descname">COMP_SZIP_EC</tt><em class="property"> = 4</em><a class="headerlink" href="#pyhdf.SD.SDC.COMP_SZIP_EC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyhdf.SD.SDC.COMP_SZIP_NN">
<tt class="descname">COMP_SZIP_NN</tt><em class="property"> = 32</em><a class="headerlink" href="#pyhdf.SD.SDC.COMP_SZIP_NN" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyhdf.SD.SDC.COMP_SZIP_RAW">
<tt class="descname">COMP_SZIP_RAW</tt><em class="property"> = 128</em><a class="headerlink" href="#pyhdf.SD.SDC.COMP_SZIP_RAW" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyhdf.SD.SDC.CREATE">
<tt class="descname">CREATE</tt><em class="property"> = 4</em><a class="headerlink" href="#pyhdf.SD.SDC.CREATE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyhdf.SD.SDC.FILL">
<tt class="descname">FILL</tt><em class="property"> = 0</em><a class="headerlink" href="#pyhdf.SD.SDC.FILL" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyhdf.SD.SDC.FLOAT32">
<tt class="descname">FLOAT32</tt><em class="property"> = 5</em><a class="headerlink" href="#pyhdf.SD.SDC.FLOAT32" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyhdf.SD.SDC.FLOAT64">
<tt class="descname">FLOAT64</tt><em class="property"> = 6</em><a class="headerlink" href="#pyhdf.SD.SDC.FLOAT64" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyhdf.SD.SDC.INT16">
<tt class="descname">INT16</tt><em class="property"> = 22</em><a class="headerlink" href="#pyhdf.SD.SDC.INT16" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyhdf.SD.SDC.INT32">
<tt class="descname">INT32</tt><em class="property"> = 24</em><a class="headerlink" href="#pyhdf.SD.SDC.INT32" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyhdf.SD.SDC.INT8">
<tt class="descname">INT8</tt><em class="property"> = 20</em><a class="headerlink" href="#pyhdf.SD.SDC.INT8" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyhdf.SD.SDC.NOFILL">
<tt class="descname">NOFILL</tt><em class="property"> = 256</em><a class="headerlink" href="#pyhdf.SD.SDC.NOFILL" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyhdf.SD.SDC.READ">
<tt class="descname">READ</tt><em class="property"> = 1</em><a class="headerlink" href="#pyhdf.SD.SDC.READ" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyhdf.SD.SDC.TRUNC">
<tt class="descname">TRUNC</tt><em class="property"> = 256</em><a class="headerlink" href="#pyhdf.SD.SDC.TRUNC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyhdf.SD.SDC.UCHAR">
<tt class="descname">UCHAR</tt><em class="property"> = 3</em><a class="headerlink" href="#pyhdf.SD.SDC.UCHAR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyhdf.SD.SDC.UCHAR8">
<tt class="descname">UCHAR8</tt><em class="property"> = 3</em><a class="headerlink" href="#pyhdf.SD.SDC.UCHAR8" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyhdf.SD.SDC.UINT16">
<tt class="descname">UINT16</tt><em class="property"> = 23</em><a class="headerlink" href="#pyhdf.SD.SDC.UINT16" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyhdf.SD.SDC.UINT32">
<tt class="descname">UINT32</tt><em class="property"> = 25</em><a class="headerlink" href="#pyhdf.SD.SDC.UINT32" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyhdf.SD.SDC.UINT8">
<tt class="descname">UINT8</tt><em class="property"> = 21</em><a class="headerlink" href="#pyhdf.SD.SDC.UINT8" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyhdf.SD.SDC.UNLIMITED">
<tt class="descname">UNLIMITED</tt><em class="property"> = 0</em><a class="headerlink" href="#pyhdf.SD.SDC.UNLIMITED" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyhdf.SD.SDC.WRITE">
<tt class="descname">WRITE</tt><em class="property"> = 2</em><a class="headerlink" href="#pyhdf.SD.SDC.WRITE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyhdf.SD.SDC.equivNumericTypes">
<tt class="descname">equivNumericTypes</tt><em class="property"> = [5, 6, 20, 21, 22, 23, 24, 25, 4, 3]</em><a class="headerlink" href="#pyhdf.SD.SDC.equivNumericTypes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyhdf.SD.SDS">
<em class="property">class </em><tt class="descclassname">pyhdf.SD.</tt><tt class="descname">SDS</tt><big>(</big><em>sd</em>, <em>id</em><big>)</big><a class="headerlink" href="#pyhdf.SD.SDS" title="Permalink to this definition">¶</a></dt>
<dd><p>The SDS class implements an HDF dataset object.
To create an SDS instance, call the create() or select()
methods of the SD class. To set attributes on an SDS instance,
call the SDS.attr() method to create an attribute instance,
then call the methods of this instance. Attributes can also be
set using the &#8220;dot notation&#8221;.</p>
<dl class="method">
<dt id="pyhdf.SD.SDS.attr">
<tt class="descname">attr</tt><big>(</big><em>name_or_index</em><big>)</big><a class="headerlink" href="#pyhdf.SD.SDS.attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an SDAttr instance representing an SDS
(dataset) attribute.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>name_or_index   attribute name or index number; if a name is</dt>
<dd>given, the attribute may not exist</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>SDAttr instance for the attribute. Call the methods of this
class to query, read or set the attribute.</dd>
</dl>
<p>C library equivalent : no equivalent</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.SD.SDS.attributes">
<tt class="descname">attributes</tt><big>(</big><em>full=0</em><big>)</big><a class="headerlink" href="#pyhdf.SD.SDS.attributes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionnary describing every attribute defined
on the dataset.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>full      true to get complete info about each attribute</dt>
<dd>false to report only each attribute value</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><p class="first">Empty dictionnary if no attribute defined.
Otherwise, dictionnary where each key is the name of a
dataset attribute. If parameter &#8216;full&#8217; is false,
key value is the attribute value. If &#8216;full&#8217; is true,
key value is a tuple with the following elements:</p>
<blockquote class="last">
<div><ul class="simple">
<li>attribute value</li>
<li>attribute index number</li>
<li>attribute type</li>
<li>attribute length</li>
</ul>
</div></blockquote>
</dd>
</dl>
<p>C library equivalent : no equivalent</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.SD.SDS.checkempty">
<tt class="descname">checkempty</tt><big>(</big><big>)</big><a class="headerlink" href="#pyhdf.SD.SDS.checkempty" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine whether the dataset is empty.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>no argument</dd>
<dt>Returns:</dt>
<dd>True(1) if dataset is empty, False(0) if not</dd>
</dl>
<p>C library equivalent : SDcheckempty</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.SD.SDS.dim">
<tt class="descname">dim</tt><big>(</big><em>dim_index</em><big>)</big><a class="headerlink" href="#pyhdf.SD.SDS.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an SDim instance given a dimension index number.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>dim_index index number of the dimension (numbering starts at 0)</dd>
</dl>
<p>C library equivalent : SDgetdimid</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.SD.SDS.dimensions">
<tt class="descname">dimensions</tt><big>(</big><em>full=0</em><big>)</big><a class="headerlink" href="#pyhdf.SD.SDS.dimensions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionnary describing every dataset dimension.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>full      true to get complete info about each dimension</dt>
<dd>false to report only each dimension length</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><p class="first">Dictionnary where each key is a dimension name. If no name
has been given to the dimension, the key is set to
&#8216;fakeDimx&#8217; where &#8216;x&#8217; is the dimension index number.
If parameter &#8216;full&#8217; is false, key value is the dimension
length. If &#8216;full&#8217; is true, key value is a 5-element tuple
with the following elements:</p>
<blockquote class="last">
<div><ul class="simple">
<li>dimension length; for an unlimited dimension, the reported
length is the current dimension length</li>
<li>dimension index number</li>
<li>1 if the dimension is unlimited, 0 otherwise</li>
<li>dimension scale type, or 0 if no scale is defined for
the dimension</li>
<li>number of attributes defined on the dimension</li>
</ul>
</div></blockquote>
</dd>
</dl>
<p>C library equivalent : no equivalent</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.SD.SDS.endaccess">
<tt class="descname">endaccess</tt><big>(</big><big>)</big><a class="headerlink" href="#pyhdf.SD.SDS.endaccess" title="Permalink to this definition">¶</a></dt>
<dd><p>Terminates access to the SDS.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>no argument</dd>
<dt>Returns: </dt>
<dd>None.</dd>
</dl>
<p>The SDS instance should not be used afterwards.
The &#8216;endaccess()&#8217; method is implicitly called when
the SDS instance is deleted.</p>
<p>C library equivalent : SDendaccess</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.SD.SDS.get">
<tt class="descname">get</tt><big>(</big><em>start=None</em>, <em>count=None</em>, <em>stride=None</em><big>)</big><a class="headerlink" href="#pyhdf.SD.SDS.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Read data from the dataset.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first docutils">
<dt>start <span class="classifier-delimiter">:</span> <span class="classifier">indices where to start reading in the data array;</span></dt>
<dd>default to 0 on all dimensions</dd>
<dt>count <span class="classifier-delimiter">:</span> <span class="classifier">number of values to read along each dimension;</span></dt>
<dd>default to the current length of all dimensions</dd>
<dt>stride <span class="classifier-delimiter">:</span> <span class="classifier">sampling interval along each dimension;</span></dt>
<dd>default to 1 on all dimensions</dd>
</dl>
<p>For n-dimensional datasets, those 3 parameters are entered 
using lists. For one-dimensional datasets, integers
can also be used.</p>
<p class="last">Note that, to read the whole dataset contents, one should
simply call the method with no argument.</p>
</dd>
<dt>Returns: </dt>
<dd>numpy array initialized with the data.</dd>
</dl>
<p>C library equivalent : SDreaddata</p>
<p>The dataset can also be read using the familiar indexing and
slicing notation, like ordinary python sequences.
See &#8220;High level variable access&#8221;.</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.SD.SDS.getcal">
<tt class="descname">getcal</tt><big>(</big><big>)</big><a class="headerlink" href="#pyhdf.SD.SDS.getcal" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the SDS calibration coefficients.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>no argument</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>5-element tuple holding :</dt>
<dd><p class="first">-cal: calibration factor (attribute &#8216;scale_factor&#8217;)
-cal_error : calibration factor error</p>
<blockquote>
<div>(attribute &#8216;scale_factor_err&#8217;)</div></blockquote>
<p>-offset: calibration offset (attribute &#8216;add_offset&#8217;)
-offset_err : offset error (attribute &#8216;add_offset_err&#8217;)
-data_type : type of the data resulting from applying</p>
<blockquote class="last">
<div>the calibration formula to the dataset values
(attribute &#8216;calibrated_nt&#8217;)</div></blockquote>
</dd>
</dl>
</dd>
</dl>
<p>An exception is raised if no calibration data are defined.</p>
<p>Original dataset values &#8216;orival&#8217; are converted to calibrated
values &#8216;calval&#8217; through the formula :</p>
<blockquote>
<div>calval = cal * (orival - offset)</div></blockquote>
<p>The calibration coefficients are part of the so-called
&#8220;standard&#8221; SDS attributes. The values inside the tuple returned 
by &#8216;getcal&#8217; are those of the following attributes, in order :</p>
<blockquote>
<div>scale_factor, scale_factor_err, add_offset, add_offset_err,
calibrated_nt</div></blockquote>
<p>C library equivalent: SDgetcal()</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.SD.SDS.getcompress">
<tt class="descname">getcompress</tt><big>(</big><big>)</big><a class="headerlink" href="#pyhdf.SD.SDS.getcompress" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves info about dataset compression type and mode.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>no argument</dd>
<dt>Returns: </dt>
<dd><dl class="first last docutils">
<dt>tuple holding :</dt>
<dd><p class="first">-compression type (one of the SDC.COMP_xxx constants)
-optional values, depending on the compression type</p>
<blockquote class="last">
<div><p>COMP_NONE       0 value    no additional value
COMP_SKPHUFF    1 value  : skip size
COMP_DEFLATE    1 value  : gzip compression level (1 to 9)
COMP_SZIP       5 values : options mask,</p>
<blockquote>
<div><p>pixels per block (2 to 32)
pixels per scanline,
bits per pixel (number of bits in the SDS datatype) 
pixels (number of elements in the SDS)</p>
<p>Note: in the context of an SDS, the word &#8220;pixel&#8221;
should really be understood as meaning &#8220;data element&#8221;,
eg a cell value inside a multidimensional grid.
Test the options mask against constants SDC.COMP_SZIP_NN
and SDC.COMP_SZIP_EC, eg :</p>
<blockquote>
<div><dl class="docutils">
<dt>if optionMask &amp; SDC.COMP_SZIP_EC:</dt>
<dd>print &#8220;EC encoding scheme used&#8221;</dd>
</dl>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
<p>An exception is raised if dataset is not compressed.
NOTE. Starting with v0.8, an exception is always raised if</p>
<blockquote>
<div>pyhdf was installed with the NOCOMPRESS macro set.</div></blockquote>
<p>C library equivalent: SDgetcompress</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.SD.SDS.getdatastrs">
<tt class="descname">getdatastrs</tt><big>(</big><big>)</big><a class="headerlink" href="#pyhdf.SD.SDS.getdatastrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the dataset standard string attributes.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>no argument</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>4-element tuple holding :</dt>
<dd>-dataset label string (attribute &#8216;long_name&#8217;)
-dataset unit (attribute &#8216;units&#8217;)
-dataset output format (attribute &#8216;format&#8217;)
-dataset coordinate system (attribute &#8216;coordsys&#8217;)</dd>
</dl>
</dd>
</dl>
<p>The values returned by &#8216;getdatastrs&#8217; are part of the
so-called &#8220;standard&#8221; SDS attributes.  Those 4 values 
correspond respectively to the following attributes:</p>
<blockquote>
<div>long_name, units, format, coordsys .</div></blockquote>
<p>C library equivalent: SDgetdatastrs</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.SD.SDS.getfillvalue">
<tt class="descname">getfillvalue</tt><big>(</big><big>)</big><a class="headerlink" href="#pyhdf.SD.SDS.getfillvalue" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the dataset fill value.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>no argument</dd>
<dt>Returns:</dt>
<dd>dataset fill value (attribute &#8216;_FillValue&#8217;)</dd>
</dl>
<p>An exception is raised if the fill value is not set.</p>
<p>The fill value is part of the so-called &#8220;standard&#8221; SDS
attributes, and corresponds to the following attribute :</p>
<blockquote>
<div>_FillValue</div></blockquote>
<p>C library equivalent: SDgetfillvalue</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.SD.SDS.getrange">
<tt class="descname">getrange</tt><big>(</big><big>)</big><a class="headerlink" href="#pyhdf.SD.SDS.getrange" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the dataset min and max values.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>no argument</dd>
<dt>Returns: </dt>
<dd><p class="first">(min, max) tuple (attribute &#8216;valid_range&#8217;)</p>
<p class="last">Note that those are the values as stored
by the &#8216;setrange&#8217; method. &#8216;getrange&#8217; does <em>NOT</em> compute the
min and max from the current dataset contents.</p>
</dd>
</dl>
<p>An exception is raised if the range is not set.</p>
<p>The range returned by &#8216;getrange&#8217; is part of the so-called 
&#8220;standard&#8221; SDS attributes. It corresponds to the following
attribute :</p>
<blockquote>
<div>valid_range</div></blockquote>
<p>C library equivalent: SDgetrange</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.SD.SDS.info">
<tt class="descname">info</tt><big>(</big><big>)</big><a class="headerlink" href="#pyhdf.SD.SDS.info" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves information about the dataset.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>no argument</dd>
<dt>Returns: </dt>
<dd><dl class="first last docutils">
<dt>5-element tuple holding :</dt>
<dd><p class="first">-dataset name
-dataset rank (number of dimensions)
-dataset shape, that is a list giving the length of each</p>
<blockquote>
<div>dataset dimension; if the first dimension is unlimited, then
the first value of the list gives the current length of the
unlimited dimension</div></blockquote>
<p class="last">-data type (one of the SDC.xxx values)
-number of attributes defined for the dataset</p>
</dd>
</dl>
</dd>
</dl>
<p>C library equivalent : SDgetinfo</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.SD.SDS.iscoordvar">
<tt class="descname">iscoordvar</tt><big>(</big><big>)</big><a class="headerlink" href="#pyhdf.SD.SDS.iscoordvar" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine whether the dataset is a coordinate variable 
(holds a dimension scale). A coordinate variable is created
when a dimension is assigned a set of scale values.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>no argument</dd>
<dt>Returns:</dt>
<dd>True(1) if the dataset represents a coordinate variable, 
False(0) if not</dd>
</dl>
<p>C library equivalent : SDiscoordvar</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.SD.SDS.isrecord">
<tt class="descname">isrecord</tt><big>(</big><big>)</big><a class="headerlink" href="#pyhdf.SD.SDS.isrecord" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines whether the dataset is appendable 
(contains an unlimited dimension). Note that if true, then
the unlimited dimension is always dimension number 0.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>no argument</dd>
<dt>Returns:</dt>
<dd>True(1) if the dataset is appendable, False(0) if not.</dd>
</dl>
<p>C library equivalent : SDisrecord</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.SD.SDS.ref">
<tt class="descname">ref</tt><big>(</big><big>)</big><a class="headerlink" href="#pyhdf.SD.SDS.ref" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the reference number of the dataset.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>no argument</dd>
<dt>Returns:</dt>
<dd>dataset reference number</dd>
</dl>
<p>C library equivalent : SDidtoref</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.SD.SDS.set">
<tt class="descname">set</tt><big>(</big><em>data</em>, <em>start=None</em>, <em>count=None</em>, <em>stride=None</em><big>)</big><a class="headerlink" href="#pyhdf.SD.SDS.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Write data to the dataset.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first docutils">
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">array of data to write; can be given as a numpy</span></dt>
<dd>array, or as Python sequence (whose elements can be
imbricated sequences)</dd>
<dt>start <span class="classifier-delimiter">:</span> <span class="classifier">indices where to start writing in the dataset;</span></dt>
<dd>default to 0 on all dimensions</dd>
<dt>count <span class="classifier-delimiter">:</span> <span class="classifier">number of values to write along each dimension;</span></dt>
<dd>default to the current length of dataset dimensions</dd>
<dt>stride <span class="classifier-delimiter">:</span> <span class="classifier">sampling interval along each dimension;</span></dt>
<dd>default to 1 on all dimensions</dd>
</dl>
<p>For n-dimensional datasets, those 3 parameters are entered 
using lists. For one-dimensional datasets, integers
can also be used.</p>
<p class="last">Note that, to write the whole dataset at once, one has simply
to call the method with the dataset values in parameter
&#8216;data&#8217;, omitting all other parameters.</p>
</dd>
<dt>Returns: </dt>
<dd>None.</dd>
</dl>
<p>C library equivalent : SDwritedata</p>
<p>The dataset can also be written using the familiar indexing and
slicing notation, like ordinary python sequences.
See &#8220;High level variable access&#8221;.</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.SD.SDS.setcal">
<tt class="descname">setcal</tt><big>(</big><em>cal</em>, <em>cal_error</em>, <em>offset</em>, <em>offset_err</em>, <em>data_type</em><big>)</big><a class="headerlink" href="#pyhdf.SD.SDS.setcal" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the dataset calibration coefficients.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">cal         the calibraton factor (attribute &#8216;scale_factor&#8217;)
cal_error   calibration factor error</p>
<blockquote>
<div>(attribute &#8216;scale_factor_err&#8217;)</div></blockquote>
<p>offset      offset value (attribute &#8216;add_offset&#8217;)
offset_err  offset error (attribute &#8216;add_offset_err&#8217;)
data_type   data type of the values resulting from applying the</p>
<blockquote class="last">
<div>calibration formula to the dataset values
(one of the SDC.xxx constants)
(attribute &#8216;calibrated_nt&#8217;)</div></blockquote>
</dd>
<dt>Returns: </dt>
<dd>None</dd>
</dl>
<p>See method &#8216;getcal&#8217; for the definition of the calibration
formula.</p>
<p>Calibration coefficients are part of the so-called standard
SDS attributes. Calling &#8216;setcal&#8217; is equivalent to setting 
the following attributes, which correspond to the method 
parameters, in order:</p>
<blockquote>
<div>scale_factor, scale_factor_err, add_offset, add_offset_err,
calibrated_nt</div></blockquote>
<p>C library equivalent: SDsetcal</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.SD.SDS.setcompress">
<tt class="descname">setcompress</tt><big>(</big><em>comp_type</em>, <em>value=0</em>, <em>v2=0</em><big>)</big><a class="headerlink" href="#pyhdf.SD.SDS.setcompress" title="Permalink to this definition">¶</a></dt>
<dd><p>Compresses the dataset using a specified compression method.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>comp_type    compression type, identified by one of the</dt>
<dd>SDC.COMP_xxx constants</dd>
<dt>value,v2     auxiliary value(s) needed by some compression types</dt>
<dd><p class="first">SDC.COMP_SKPHUFF   Skipping-Huffman; compression value=data size in bytes, v2 is ignored
SDC.COMP_DEFLATE   Gzip compression; value=deflate level (1 to 9), v2 is ignored
SDC.COMP_SZIP      Szip compression; value=encoding scheme (SDC.COMP_SZIP_EC or</p>
<blockquote class="last">
<div>SDC.COMP_SZIP_NN), v2=pixels per block (2 to 32)</div></blockquote>
</dd>
</dl>
</dd>
<dt>Returns: None</dt>
<dd><dl class="first last docutils">
<dt>NOTE. Starting with v0.8, an exception is always raised if</dt>
<dd>pyhdf was installed with the NOCOMPRESS macro set.</dd>
</dl>
</dd>
</dl>
<p>SDC.COMP_DEFLATE applies the GZIP compression to the dataset,
and the value varies from 1 to 9, according to the level of
compression desired.</p>
<p>SDC.COMP_SZIP compresses the dataset using the SZIP algorithm. See the HDF User&#8217;s Guide
for details about the encoding scheme and the number of pixels per block. SZIP is new
with HDF 4.2.</p>
<p>&#8216;setcompress&#8217; must be called before writing to the dataset.
The dataset must be written all at once, unless it is 
appendable (has an unlimited dimension). Updating the dataset
in not allowed. Refer to the HDF user&#8217;s guide for more details 
on how to use data compression.</p>
<p>C library equivalent: SDsetcompress</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.SD.SDS.setdatastrs">
<tt class="descname">setdatastrs</tt><big>(</big><em>label</em>, <em>unit</em>, <em>format</em>, <em>coord_sys</em><big>)</big><a class="headerlink" href="#pyhdf.SD.SDS.setdatastrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the dataset standard string type attributes.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>label         dataset label (attribute &#8216;long_name&#8217;)
unit          dataset unit (attribute &#8216;units&#8217;)
format        dataset format (attribute &#8216;format&#8217;)
coord_sys     dataset coordinate system (attribute &#8216;coordsys&#8217;)</dd>
<dt>Returns:</dt>
<dd>None</dd>
</dl>
<p>Those strings are part of the so-called standard
SDS attributes. Calling &#8216;setdatastrs&#8217; is equivalent to setting 
the following attributes, which correspond to the method 
parameters, in order:</p>
<blockquote>
<div>long_name, units, format, coordsys</div></blockquote>
<p>C library equivalent: SDsetdatastrs</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.SD.SDS.setexternalfile">
<tt class="descname">setexternalfile</tt><big>(</big><em>filename</em>, <em>offset=0</em><big>)</big><a class="headerlink" href="#pyhdf.SD.SDS.setexternalfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Store the dataset data in an external file.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">filename    external file name
offset      offset in bytes where to start writing in</p>
<blockquote class="last">
<div>the external file</div></blockquote>
</dd>
</dl>
<p>Returns: None</p>
<p>C library equivalent : SDsetexternalfile</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.SD.SDS.setfillvalue">
<tt class="descname">setfillvalue</tt><big>(</big><em>fill_val</em><big>)</big><a class="headerlink" href="#pyhdf.SD.SDS.setfillvalue" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the dataset fill value.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>fill_val   dataset fill value (attribute &#8216;_FillValue&#8217;)</dd>
<dt>Returns: </dt>
<dd>None</dd>
</dl>
<p>The fill value is part of the so-called &#8220;standard&#8221; SDS
attributes. Calling &#8216;setfillvalue&#8217; is equivalent to setting
the following attribute:</p>
<blockquote>
<div>_FillValue</div></blockquote>
<p>C library equivalent: SDsetfillvalue</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.SD.SDS.setrange">
<tt class="descname">setrange</tt><big>(</big><em>min</em>, <em>max</em><big>)</big><a class="headerlink" href="#pyhdf.SD.SDS.setrange" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the dataset min and max values.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>min        dataset minimum value (attribute &#8216;valid_range&#8217;)
max        dataset maximum value (attribute &#8216;valid_range&#8217;)</dd>
<dt>Returns: </dt>
<dd>None</dd>
</dl>
<p>The data range is part of the so-called &#8220;standard&#8221; SDS
attributes. Calling method &#8216;setrange&#8217; is equivalent to
setting the following attribute with a 2-element [min,max]
array :</p>
<blockquote>
<div>valid_range</div></blockquote>
<p>C library equivalent: SDsetrange</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyhdf.SD.SDim">
<em class="property">class </em><tt class="descclassname">pyhdf.SD.</tt><tt class="descname">SDim</tt><big>(</big><em>sds</em>, <em>id</em>, <em>index</em><big>)</big><a class="headerlink" href="#pyhdf.SD.SDim" title="Permalink to this definition">¶</a></dt>
<dd><p>The SDim class implements a dimension object.
There can be one dimension object for each dataset dimension.
To create an SDim instance, call the dim() method of an SDS class
instance. To set attributes on an SDim instance, call the
SDim.attr() method to create an attribute instance, then call the
methods of this instance.  Attributes can also be set using the
&#8220;dot notation&#8221;.</p>
<dl class="method">
<dt id="pyhdf.SD.SDim.attr">
<tt class="descname">attr</tt><big>(</big><em>name_or_index</em><big>)</big><a class="headerlink" href="#pyhdf.SD.SDim.attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an SDAttr instance representing an SDim
(dimension) attribute.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>name_or_index   attribute name or index number; if a name is</dt>
<dd>given, the attribute may not exist; in that
case, the attribute is created when the
instance set() method is called</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>SDAttr instance for the attribute. Call the methods of this
class to query, read or set the attribute.</dd>
</dl>
<p>C library equivalent : no equivalent</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.SD.SDim.attributes">
<tt class="descname">attributes</tt><big>(</big><em>full=0</em><big>)</big><a class="headerlink" href="#pyhdf.SD.SDim.attributes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionnary describing every attribute defined
on the dimension.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>full      true to get complete info about each attribute</dt>
<dd>false to report only each attribute value</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><p class="first">Empty dictionnary if no attribute defined.
Otherwise, dictionnary where each key is the name of a
dimension attribute. If parameter &#8216;full&#8217; is false,
key value is the attribute value. If &#8216;full&#8217; is true,
key value is a tuple with the following elements:</p>
<blockquote class="last">
<div><ul class="simple">
<li>attribute value</li>
<li>attribute index number</li>
<li>attribute type</li>
<li>attribute length</li>
</ul>
</div></blockquote>
</dd>
</dl>
<p>C library equivalent : no equivalent</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.SD.SDim.getscale">
<tt class="descname">getscale</tt><big>(</big><big>)</big><a class="headerlink" href="#pyhdf.SD.SDim.getscale" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain the scale values along a dimension.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>no argument</dd>
<dt>Returns:</dt>
<dd>list with the scale values; the list length is equal to the
dimension length; the element type is equal to the dimension
data type, as set when the &#8216;setdimscale()&#8217; method was called.</dd>
</dl>
<p>C library equivalent : SDgetdimscale</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.SD.SDim.getstrs">
<tt class="descname">getstrs</tt><big>(</big><big>)</big><a class="headerlink" href="#pyhdf.SD.SDim.getstrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the dimension standard string attributes.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>no argument</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>3-element tuple holding:</dt>
<dd>-dimension label  (attribute &#8216;long_name&#8217;)
-dimension unit   (attribute &#8216;units&#8217;)
-dimension format (attribute &#8216;format&#8217;)</dd>
</dl>
</dd>
</dl>
<p>An exception is raised if the standard attributes have
not been set.</p>
<p>C library equivalent: SDgetdimstrs</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.SD.SDim.info">
<tt class="descname">info</tt><big>(</big><big>)</big><a class="headerlink" href="#pyhdf.SD.SDim.info" title="Permalink to this definition">¶</a></dt>
<dd><p>Return info about the dimension instance.</p>
<dl class="docutils">
<dt>Args :</dt>
<dd>no argument</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>4-element tuple holding:</dt>
<dd><dl class="first docutils">
<dt>-dimension name; &#8216;fakeDimx&#8217; is returned if the dimension</dt>
<dd>has not been named yet, where &#8216;x&#8217; is the dimension
index number</dd>
<dt>-dimension length; 0 is returned if the dimension is unlimited;</dt>
<dd>call the SDim.length() or SDS.info() methods to obtain the
current dimension length</dd>
<dt>-scale data type (one of the SDC.xxx constants); 0 is</dt>
<dd>returned if no scale has been set on the dimension</dd>
</dl>
<p class="last">-number of attributes attached to the dimension</p>
</dd>
</dl>
</dd>
</dl>
<p>C library equivalent : SDdiminfo</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.SD.SDim.length">
<tt class="descname">length</tt><big>(</big><big>)</big><a class="headerlink" href="#pyhdf.SD.SDim.length" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dimension length. This method is usefull
to quickly retrieve the current length of an unlimited
dimension.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>no argument</dd>
<dt>Returns:</dt>
<dd>dimension length; if the dimension is unlimited, the
returned value is the current dimension length</dd>
</dl>
<p>C library equivalent : no equivalent</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.SD.SDim.setname">
<tt class="descname">setname</tt><big>(</big><em>dim_name</em><big>)</big><a class="headerlink" href="#pyhdf.SD.SDim.setname" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the dimension name.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>dim_name    dimension name; setting 2 dimensions to the same</dt>
<dd>name make the dimensions &#8220;shared&#8221;; in order to be
shared, the dimesions must be deined similarly.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>None</dd>
</dl>
<p>C library equivalent : SDsetdimname</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.SD.SDim.setscale">
<tt class="descname">setscale</tt><big>(</big><em>data_type</em>, <em>scale</em><big>)</big><a class="headerlink" href="#pyhdf.SD.SDim.setscale" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the scale values along the dimension.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">data_type    data type code (one of the SDC.xxx constants)
scale        sequence holding the scale values; the number of</p>
<blockquote class="last">
<div>values must match the current length of the dataset 
along that dimension</div></blockquote>
</dd>
</dl>
<p>C library equivalent : SDsetdimscale</p>
<p>Setting a scale on a dimension generates what HDF calls a
&#8220;coordinate variable&#8221;. This is a rank 1 dataset similar to any
other dataset, which is created to hold the scale values. The
dataset name is identical to that of the dimension on which
setscale() is called, and the data type passed in &#8216;data_type&#8217;
determines the type of the dataset. To distinguish between such
a dataset and a &#8220;normal&#8221; dataset, call the iscoordvar() method
of the dataset instance.</p>
</dd></dl>

<dl class="method">
<dt id="pyhdf.SD.SDim.setstrs">
<tt class="descname">setstrs</tt><big>(</big><em>label</em>, <em>unit</em>, <em>format</em><big>)</big><a class="headerlink" href="#pyhdf.SD.SDim.setstrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the dimension standard string attributes.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>label   dimension label  (attribute &#8216;long_name&#8217;)
unit    dimension unit   (attribute &#8216;units&#8217;)
format  dimension format (attribute &#8216;format&#8217;)</dd>
<dt>Returns: </dt>
<dd>None</dd>
</dl>
<p>C library equivalent: SDsetdimstrs</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="pyhdf.SD.HDF4Error">
<em class="property">exception </em><tt class="descclassname">pyhdf.SD.</tt><tt class="descname">HDF4Error</tt><a class="headerlink" href="#pyhdf.SD.HDF4Error" title="Permalink to this definition">¶</a></dt>
<dd><p>An error from inside the HDF4 library.</p>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Table of contents</a></li>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#sd-module-key-features">SD module key features</a></li>
<li><a class="reference internal" href="#accessing-the-sd-module">Accessing the SD module</a></li>
<li><a class="reference internal" href="#package-components">Package components</a></li>
<li><a class="reference internal" href="#prerequisites">Prerequisites</a></li>
<li><a class="reference internal" href="#documentation">Documentation</a></li>
<li><a class="reference internal" href="#summary-of-differences-between-the-pyhdf-and-c-sd-api">Summary of differences between the pyhdf and C SD API</a></li>
<li><a class="reference internal" href="#error-handling">Error handling</a></li>
<li><a class="reference internal" href="#attribute-access-low-and-high-level">Attribute access: low and high level</a></li>
<li><a class="reference internal" href="#variable-access-low-and-high-level">Variable access: low and high level</a></li>
<li><a class="reference internal" href="#reading-setting-multivalued-hdf-attributes-and-variables">Reading/setting multivalued HDF attributes and variables</a></li>
<li><a class="reference internal" href="#netcdf-files">netCDF files</a></li>
<li><a class="reference internal" href="#classes-summary">Classes summary</a></li>
<li><a class="reference internal" href="#data-types">Data types</a></li>
<li><a class="reference internal" href="#programming-models">Programming models</a></li>
<li><a class="reference internal" href="#writing">Writing</a></li>
<li><a class="reference internal" href="#reading">Reading</a></li>
<li><a class="reference internal" href="#examples">Examples</a></li>
<li><a class="reference internal" href="#example-1">Example-1</a></li>
<li><a class="reference internal" href="#example-2">Example 2</a></li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="HDF.html"
                        title="previous chapter">Introduction</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="VS.html"
                        title="next chapter">Table of contents</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/modules/SD.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="VS.html" title="Table of contents"
             >next</a> |</li>
        <li class="right" >
          <a href="HDF.html" title="Introduction"
             >previous</a> |</li>
        <li><a href="../index.html">pyhdf 0.9 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, pyhdf authors.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>